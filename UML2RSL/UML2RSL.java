/**
 ** UML2RSL.java 

 ** Update: 27/Sep/2002: 
    ===================

 ** Corrects bug in generation of leaf classes without attributes.
 
 ** Eliminates the _Classname extension to the identifiers in the module for
    a collection.

 ** Creates the RSL directory whenever it does not exist and the user allows to. It must be given as the second
    argument to the java command line. (java -classpath <XML parser path> UML2RSL <umldiagram.xml> <RSL path>)

 ** Translates data types boolean, char and double in Magic Draw to the corresponding  data types Bool, Char and Real 
    in RSL. 

 ** Checks the absence of RSL keyword used as identifiers in the UML model. Only RSL types can be used as types
    in the UML model.

 ** Changes the names of the functions in the top level module S to make them consistent with the style used for
    the  destructors of the type Sys. 

 ** Fixes a bug in the function consistent of the top-level module.

 ** Append an "_" to the generated RSL module names in order to avoid clash of names when  c++ translator is used.

 ** Modifies the parsing for the instantiation relationship since Magic Draw  version 5.0 produces a different XMLcode.

 ** Modifies the parsing for the template class  arguments since Magic Draw  version 5.0 produces a different XMLcode.

 ** Update 30/Oct/02:
    ================

 ** Fixes method validPars to check the use of RSL keywords.

 ** Modifies method classformalParCode (changes "FPAR:" to "FPAR: with TYPES in"). 

 ** Accepts instantiated classes with formal parameters (templates). 

 ** Update 5/Nov/02:
    ================

 ** Modifies constraint for addOnly changeability in attributes and associations. 

 ** Update 13/Nov/02:
    ================

 ** Eliminates function allowedInGeneralization(), because it is not necessary.

 ** Update 17/Feb/04:
    ================

 ** Multiplicity -1..-1 treated as *..* for Magicdraw 7.5

 ** Missing isNavigable means false for Magicdraw 7.5

 ** Update: 2/Mar/04: 
    =================

 ** Accepts xmi version 1.2 documents

 ** Update 20/Feb/05
    ================

 ** Accepts xmi version 1.0, 1.1, and 1.2 documents
    (on basis that 1.1 and 1.2 seem equivalent for this tool)

 ** Update 18/May/07
    ================

 ** Correction to find UML Standard Profile Types generated by Magic Draw 9.5

 **/


import org.w3c.dom.*;
import org.apache.xerces.parsers.DOMParser;
import java.util.*;
import java.lang.*;
import java.io.*;

public class UML2RSL {
    
    private static DOMParser parser;
    private static String xmiversion;
    private static ClassDiagram cd;
    private static boolean exito = true;
    private final static int CHANGEABLE = 0;
    private final static int FROZEN = 1;
    private final static int ADDONLY = 2;

    // 1.1 and 1.2 settings; changed by setForVersion0 later if 1.0
    private static boolean isVersion0 = false;
    private static String COREPREFIX = "UML:";
    private static String MODELTAGNAME = "UML:Model";
    private static String OWNEDELEMENTNAME = "UML:Namespace.ownedElement";
    private static String CLASSTAGNAME = "UML:Class";
    private static String PACKAGETAGNAME = "UML:Package";
    private static String MULTIPLICITYTAGNAME = "UML:Multiplicity";
    

    public static void main(String[] args){

        try {   
            parser = new DOMParser();
	    if (args.length != 2)
		showCommandLineFormat();
	    else {
		if (existsFile(args[0])) { 
		    parser.parse(args[0]);
		    generateCD();  // process the whole document for generating cd
		    //cd.print();
		    if (exito) {
			//cd.print();
			if (cd.wellFormed()) 
			    cd.code(args[1]);  // produce RSL code
		    }
		} 
	    }   
	}
	catch (Exception e) {
	    e.printStackTrace(System.err);
	}
    }

    private static void setForVersion0(){
	// settings for XMI version 1.0
	System.out.println("XMI version is 1.0");
	isVersion0 = true;
	COREPREFIX = "Foundation.Core.";
	MODELTAGNAME = "Model_Management.Model";
	OWNEDELEMENTNAME = "Foundation.Core.Namespace.ownedElement";
	CLASSTAGNAME = "Foundation.Core.Class";
	PACKAGETAGNAME = "Model_Management.Package";
	MULTIPLICITYTAGNAME = "Foundation.Data_Types.Multiplicity";
    }

    private static  void showCommandLineFormat(){

	System.out.println("Error: Invalid java command line.");
	System.out.println("Format: java -classpath .:<path to XMLparser xerces.jar> UML2RSL " +
			   "<path to XML inputfile> < path to RSL output directory>");		
    }


    private static boolean existsFile(String fn) {
    
	File xmlFile = new File(fn);
	boolean exists = true;
	 
       	if (!xmlFile.isFile()) { 
	    //true if and only if the file denoted by this abstract pathname exists and is a normal file; false otherwise 
	    System.out.println("Error in input file: nonexistent XML input file " + xmlFile.getPath());
	    exists = false;
	} 
	
	return exists;
    }
        

    private static void  generateCD(){

        Node model_node = null;

        Document doc = parser.getDocument(); // get the whole document
        Element root = doc.getDocumentElement();  // get node <XMI>
	Node item = root.getAttributes().getNamedItem("xmi.version");
	if (item != null){
	    xmiversion = item.getNodeValue().trim();
	    System.out.println("XMI version: " + xmiversion);
	    if (xmiversion.equals("1.0")) {setForVersion0();}
	}
	else {
	    System.out.println("Error: XMI version not found");
            exito = false;
        }
	    
	Node content_node = searchChild(root, "XMI.content");
	if (content_node != null) {
	    model_node = searchChild(content_node, MODELTAGNAME);
	}

        if (model_node == null) {
            System.out.println("Error: " + MODELTAGNAME + " not found");
            exito = false;
        }
        else {
            cd = new ClassDiagram(new Vector<Clase>(100,1), new Vector<Object>(100,1));
             processModel(model_node); // process node <MODELTAGNAME>
        }
    }


    private static void processModel(Node model){
        
        Node nameSpace = searchChild(model, OWNEDELEMENTNAME);

        if (nameSpace != null) {
            processClasses(nameSpace);
            if (exito) {
                processPackages(nameSpace);
                if (exito){
                    processAssociations(nameSpace);
                    if (exito) {
                        processDependencies(nameSpace);
                        if (exito){
                            processGeneralizations(nameSpace);
                            if (exito) 
                                processInstantiations(nameSpace);
                                
                        }
                    }
                }
            }
        }

    }


    private static void  processClasses(Node node){

        for (Node curNode = node.getFirstChild(); curNode != null & exito ; 
             curNode = curNode.getNextSibling()) {
            if  (curNode instanceof Element) {
                if (curNode.getNodeName().equals(CLASSTAGNAME)) {
                    processClass(curNode);
                    Node child = searchChild(curNode, OWNEDELEMENTNAME);
                    if (child != null) {
                        processClasses(child);  // process nested classes
                        if (exito){
                            processAssociations(child);
                            if (exito) {
                                processDependencies(child);
                                if (exito){
                                    processGeneralizations(child);
                                    if (exito) 
                                        processInstantiations(child);
                                }
                            }
                        }
                    }
                }
            }
        }
    }


    private static void  processPackages(Node node){

        for (Node curNode = node.getFirstChild(); curNode != null & exito ; 
             curNode = curNode.getNextSibling()) {
            if  (curNode instanceof Element) {
                if (curNode.getNodeName().equals(PACKAGETAGNAME)){
                    Node child = searchChild(curNode, OWNEDELEMENTNAME);
                    if (child != null) {
                        processPackages(child);     // process nested packages
                        if (exito){
                            processClasses(child); 
                            if (exito) {
                                processAssociations(child);
                                if (exito) {
                                    processDependencies(child);
                                    if (exito){
                                        processGeneralizations(child);
                                        if (exito) 
                                            processInstantiations(child);
                                    }
                                }
                            }
                        }
                    }
                }    
            }
        }
    }

    
    private static void processClass(Node cl){

        Clase clase ;
        String classname;
        Vector<Attribute> attributes;
        Vector<Operation> operations;
        Multiplicity multiplicity;
        boolean is_abstract;
        boolean is_root;
        boolean is_leaf;
        Vector<FormalParameter> parameters;

        classname = getName(cl);
        if (classname == null){
            exito =false;
            System.out.println("Error: Class without name");
        }    
        if (exito) {
            attributes = getClassAttributes(cl);
            if (exito) {
                operations = getClassOperations(cl);
                if (exito) {
                    multiplicity = getClassMultiplicity(cl);
                    if (exito) {
                        is_abstract = getIs_abstract(cl);
                        if (exito) {
                            is_root = getIs_root(cl);
                            if (exito) {
                                is_leaf = getIs_leaf(cl);
                                if (exito) {
                                    parameters = getClassParameters(cl);
                                    if (exito) {
                                        clase = new Clase(classname, attributes, operations,
                                                      multiplicity, is_abstract, is_root, is_leaf,
                                                      parameters);
                                        cd.classes.addElement(clase);
                                    }
                                }
                            } 
                        }
                    }
                }
            }
        }
    }


    private static String getName(Node node){

        Node item;
        String name = null;
	if (isVersion0) {
	    Node nameNode = searchChild(node, "Foundation.Core.ModelElement.name");
	    if (nameNode != null) {
		item = nameNode.getFirstChild();
		if (item != null) {
		    if (item instanceof Text){
			name = item.getNodeValue().trim();
			if (name == null) 
			    exito = false;
		    }
		    else exito = false;
		}
	    }
	}
	else { // xmi version 1.1 or 1.2
	    item = node.getAttributes().getNamedItem("name");
	    if (item != null){
		name = item.getNodeValue().trim();
	    }
	}
	return name;
    }

 
    private static Vector<Attribute> getClassAttributes(Node cl){
        
        Vector<Attribute> attributes = new Vector<Attribute>(10,1);
        Attribute attribute;
        Node feature = searchChild(cl, COREPREFIX + "Classifier.feature");

        if (feature != null){
            for (Node curNode = feature.getFirstChild(); curNode != null  & exito; 
                 curNode = curNode.getNextSibling()) {
                if (curNode.getNodeName().equals(COREPREFIX + "Attribute")) {  
                    attribute = getAttribute(curNode);
                    if (exito) 
                        attributes.addElement(attribute);
                }
            }
        }
        
        return attributes;

    }


    private static Attribute getAttribute(Node at){
        
        String name;
        String at_type;
        Multiplicity multiplicity;
        String scope;
        int changeability;
        Attribute attribute = null;

        name = getName(at);
        if (name == null) {
            exito = false;
            System.out.println("Error: Attribute without name");
        }
        if (exito) {
            at_type = getAttributeType(at);
            if (exito) {
                multiplicity = getAttributeMultiplicity(at);
                if (exito) {
                    scope = getScope(at);
                    if (exito) {
                        changeability = getAttributeChangeability(at);
                        attribute = new Attribute(name, name, at_type, multiplicity, scope, changeability);
                    }
                }
            }
        }
        else System.out.println("Error: Attribute without name");

        return attribute;

    }


    private static String getAttributeType(Node at) {

        String attributeType = null;
        NamedNodeMap node_attributes;

	if (isVersion0){
	    Node curNode  = searchChild(at, "Foundation.Core.StructuralFeature.type");

	    if (curNode != null) {
		curNode = curNode.getFirstChild();  // get Text
		curNode = curNode.getNextSibling(); // get <Foundation.Core.DataType>
		if (curNode.getNodeName().equals("Foundation.Core.Classifier") |  //type in Poseidon
		    curNode.getNodeName().equals("Foundation.Core.Class") |
		    curNode.getNodeName().equals("Foundation.Core.DataType")) {  // type in MagicDraw
		    node_attributes = curNode.getAttributes(); // get <Foundation.Core.DataType> attributes
		    if (node_attributes == null){
			exito = false;
			System.out.println("Error: Foundation.Core.DataType without value");
		    }
		    else {
			curNode = node_attributes.getNamedItem("xmi.idref");
			if (curNode == null){
			    exito = false;
			    System.out.println("Error: Foundation.Core.DataType without value");
			}
			else {
			    Document doc = parser.getDocument();
			    attributeType = deRef(doc, curNode.getNodeValue().trim(), null);
			    if (attributeType == null){
				exito = false;
				System.out.println("Error: Invalid reference in attribute type");
			    }
			}
		    }
		}
		else {
		    System.out.println("Error: Foundation.Core.StructuralFeature.type without value");
		    exito = false;
		}
	    }
	    else attributeType = new String("");

	}
	else {  // xmi version 1.1 or 1.2
	    Node item = null;
	    
	    node_attributes = at.getAttributes();
	    if (node_attributes != null) {
		// MagicDraw 7.5 has types as named attributes
		item = node_attributes.getNamedItem("type");
	    }
	    if (item == null) {
		// MagicDraw 9.5 uses a child node for UML standard profile types
		Node typeNode  = searchChild(at, COREPREFIX + "StructuralFeature.type");
		if (typeNode != null) {
		    // For MagicDraw
		    Node classNode = searchChild(typeNode, COREPREFIX + "Classifier");
		    if (classNode != null) {
			Node extNode = searchChild(classNode, "XMI.extension");
			if (extNode != null) {
			    for (Node curNode = extNode.getFirstChild(); curNode != null & exito;
				 curNode = curNode.getNextSibling()) {
				if (curNode.getNodeName().equals("referentPath")) {
				    item = curNode.getAttributes().getNamedItem("xmi.value");
				    attributeType = item.getNodeValue().trim();
				    if (attributeType.startsWith("UML Standard Profile::"))
					attributeType = attributeType.substring(22);
				}
			    }
			}
		    }
		    else {
		    // Poseidon uses a child node, either Class or DataType
		    classNode = searchChild(typeNode, CLASSTAGNAME);
		    if (classNode == null) {
			classNode = searchChild(typeNode, COREPREFIX + "DataType");
		    }
		    if (classNode != null) {
			item = classNode.getAttributes().getNamedItem("xmi.idref");
		    }
		    }
		}
	    }
	    if (item != null) {
		if (attributeType == null) {
		    Document doc = parser.getDocument();
		    attributeType = deRef(doc, item.getNodeValue().trim(), null);
		}
	    }
	    else {
		attributeType = new String("");
	    }
	}
        
        return attributeType;

    }


    private static Multiplicity getAttributeMultiplicity(Node at) {
        
        Multiplicity  multiplicity = null;
        Node curNode  = searchChild(at, COREPREFIX + "StructuralFeature.multiplicity");

        if (curNode != null) {
            multiplicity = getMultiplicity(curNode);
            if (multiplicity.upper.equals("-1")) {
                if (multiplicity.lower.equals("-1"))
                    multiplicity = new Multiplicity("*","*");
                else
                    multiplicity = new Multiplicity(multiplicity.lower,"*");
            }
        }
        else 
           multiplicity = new Multiplicity("1","1");

        return multiplicity;
    }
        

    private static Multiplicity getMultiplicity(Node node) {
        
        Multiplicity  multiplicity = null;
        String lower;
        String upper;
        Node curNode, aux;
        
        curNode = node.getFirstChild(); // get Text
        curNode = curNode.getNextSibling(); // get <MULTIPLICITYTAGNAME>
        aux = curNode;
        curNode = searchChild(curNode, MULTIPLICITYTAGNAME + ".range");
        while (curNode == null & exito) {
            // There is a reference to  <MULTIPLICITYTAGNAME>: it was not a child
            NamedNodeMap node_attributes = aux.getAttributes();
            if (node_attributes == null) 
                exito = false;
            else {
                Node item = node_attributes.getNamedItem("xmi.idref");
                if (item == null)
                    exito = false;
                else {
                    Document doc = parser.getDocument();
                    curNode = searchRef(doc, item.getNodeValue().trim(), null);
                    if (curNode == null){
                        exito = false;
                        System.out.println("Error: Invalid reference in multiplicity");
                    }
                    else 
                        curNode = searchChild(curNode, MULTIPLICITYTAGNAME + ".range");
                }
            }
        }
        if (exito) {
	    if (isVersion0) {
		curNode = curNode.getFirstChild(); // get Text
		if (curNode != null) {
		    curNode = curNode.getNextSibling(); // get <Foundation.Data_Type.MultiplicityRange>
		    if (curNode != null) {
			curNode = curNode.getFirstChild();  // get Text
			curNode = curNode.getNextSibling();//get <Foundation.Data_Type.Multiplicity. Range.Lower>
			if (curNode != null) {
			    curNode = curNode.getFirstChild(); // get Text
			    if (curNode != null) {
				// get lower bound
				lower = curNode.getNodeValue().trim();
				curNode = curNode.getParentNode(); //get <Foundation.Data_Type.Multiplicity. Range.Lower
				curNode = curNode.getNextSibling(); // get text
				curNode = curNode.getNextSibling(); // get <Foundation.Data_Type.Multiplicity. Range.Upper>
				if (curNode != null) {
				    curNode = curNode.getFirstChild(); // get Text
				    if (curNode != null) {
					// get upper bound  
					upper = curNode.getNodeValue().trim();
					multiplicity = new Multiplicity(lower, upper);
				    }
				    else 
					exito = false;
				}
				else 
				    exito = false;
			    }
			    else 
				exito = false;
			}
			else 
			    exito = false;
		    }
		    else 
			exito = false;
		}        
		else 
		    exito = false;
	    }
	    else { // xmi version 1.1 or 1.2
		curNode = searchChild(curNode, COREPREFIX + "MultiplicityRange");
		if (curNode != null) {
		    NamedNodeMap range_attributes = curNode.getAttributes();
		    Node lower_item = range_attributes.getNamedItem("lower");
		    if (lower_item != null) {
			lower = lower_item.getNodeValue().trim();
			Node upper_item = range_attributes.getNamedItem("upper");
			if (upper_item != null) {
			    upper = upper_item.getNodeValue().trim();
			    multiplicity = new Multiplicity(lower, upper);
			}
			else 
                            exito = false;
		    }
		    else 
			exito = false;
		}        
		else 
		    exito = false;
	    }
	}
        if (!exito)
            System.out.println("Error : multiplicity without value");
       
        return multiplicity;

    }


    private static String getScope(Node node) {
        
        String scope = null;
        Node item;

	if (isVersion0) {
	    NamedNodeMap node_attributes;
	    Node scopeNode = searchChild(node, "Foundation.Core.Feature.ownerScope");

	    if (scopeNode != null) {
		node_attributes = scopeNode.getAttributes();
		if (node_attributes != null) {
		    item = node_attributes.getNamedItem("xmi.value");
		    if (item == null){
			exito = false;
			System.out.println("Error: Foundation.Core.Feature.ownerScope without value");
		    }
		    else 
			scope = item.getNodeValue().trim();
		}
		else {
		    exito = false;
		    System.out.println("Error: Foundation.Core.Feature.ownerScope without value");
		}
	    }
	    else 
		scope = new String("instance");
	    
	}
	else { // xmi version 1.1 or 1.2
	    item = node.getAttributes().getNamedItem("ownerScope");
	    if (item != null) 
		scope = item.getNodeValue().trim();
	    else 
		scope = new String("instance");
	}

        return scope;

    }


    private static int getAttributeChangeability(Node at) {
        
        String attributeChangeability = null;
        Node item;
        int atCh = CHANGEABLE;

	if (isVersion0) {
	    NamedNodeMap node_attributes;
	    Node changeabilityNode = searchChild(at, "Foundation.Core.StructuralFeature.changeability");

	    if (changeabilityNode != null) {
		node_attributes = changeabilityNode.getAttributes();
		if (node_attributes != null) {
		    item = node_attributes.getNamedItem("xmi.value");
		    if (item == null){
			exito = false;
			System.out.println("Error: Foundation.Core.StructuralFeature.changeabilty without value");
		    }
		    else 
			attributeChangeability = item.getNodeValue().trim();
		}
		else {
		    exito = false;
		    System.out.println("Error: Foundation.Core.StructuralFeature.changeabilty without value");
		}
	    }
	    else
		attributeChangeability = new String("changeable");
	}
	else { // xmi version 1.1 or 1.2
	    item = at.getAttributes().getNamedItem("changeability");
	    if (item != null)
		attributeChangeability = item.getNodeValue().trim();
	    else
		attributeChangeability = new String("changeable");
	}

        if (attributeChangeability.toLowerCase().trim().equals("frozen"))
            atCh = FROZEN;
        else{
            if (attributeChangeability.toLowerCase().trim().equals("addonly"))
                atCh = ADDONLY;
        }

        return atCh;

    }


    private static Vector<Operation> getClassOperations(Node cl){
        
        Vector<Operation> operations = new Vector<Operation>(10,1);
        Operation operation;
        boolean found = false;
        Node curNode = searchChild(cl, COREPREFIX + "Classifier.feature");
        
        if (curNode != null) {  
            for (curNode = curNode.getFirstChild(); curNode != null  & exito; 
                 curNode = curNode.getNextSibling()) {
                if (curNode.getNodeName().equals(COREPREFIX + "Operation")) {  
                    operation = getOperation(curNode);
                    if (exito) 
                        operations.addElement(operation);
                }
            }
        }
        
        return operations;      

    }


    private static Operation getOperation(Node op){
       
        String name;
        Vector<FormalParameter> formalparameters;
        String result;
        boolean is_abstract;
        String scope;

        Operation operation = null;

        name = getName(op);
        if (name == null) {
            exito = false;
            System.out.println("Error: Operation without name");
        }
        if (exito) {
            formalparameters = getOperFormalParameters(op);
            if (exito) {
                result = getOperResult(op);
                if (exito) {
                    is_abstract = getIsAbstractOper(op); 
                    if (exito) {
                        scope =  getScope(op);
                        operation = new Operation(name, name, formalparameters, result, is_abstract, scope);
                    }
                }
                else System.out.println("Error: operation result");
            }
            else System.out.println("Error: formal parameters");
        }
        else System.out.println("Error: Operation without name");

        return operation;
    }


    private static Vector<FormalParameter> getOperFormalParameters(Node op) {
        
        Vector<FormalParameter> formalparameters = new Vector<FormalParameter>(10,1);
        FormalParameter formalparameter;
        Node behavioralNode = searchChild(op, COREPREFIX + "BehavioralFeature.parameter");

        if (behavioralNode != null) {
            for (Node parameterNode = behavioralNode.getFirstChild(); parameterNode != null & exito; 
                 parameterNode = parameterNode.getNextSibling()) {
                if (parameterNode.getNodeName().equals(COREPREFIX + "Parameter")) {  // get parameter data
		    if (isVersion0) {
			String kind = getKind(parameterNode);
			if (kind != null) {
			    if (!kind.equals("return")){
				formalparameter = getOperParameter(parameterNode);
				if (exito) 
				    formalparameters.addElement(formalparameter);
			    }
			}
			else
			    exito = false;
		    }
		    else { // xmi version 1.1 or 1.2
			Node item = parameterNode.getAttributes().getNamedItem("kind");
			String kind;
			if (item == null) {
			    // MagicDraw kind defaults to "inout"
			    kind = new String("inout");
			}
			else kind = item.getNodeValue().trim();
		    
			if (!kind.equals("return")){
			    formalparameter = getOperParameter(parameterNode);
			    if (exito)
				formalparameters.addElement(formalparameter);
			}
		    }
                }
            }
        }       

        return formalparameters;
    }

    private static String getKind(Node node) {
        
        String kind = null;
        Node kindNode = searchChild(node, COREPREFIX + "Parameter.kind");

        if (kindNode != null) {
            NamedNodeMap node_attributes = kindNode.getAttributes();
            Node item = node_attributes.getNamedItem("xmi.value");
            if (item == null) {
		System.out.println("Error: UML:Parameter.kind value missing");
                exito = false;
	    }
            else 
                kind = item.getNodeValue().trim();
        }
        else { // MagicDraw 7.5 beta defaults kind to "inout"
	    kind = new String("inout");
	}

        return kind;
            
    }


    private static FormalParameter getOperParameter(Node par) {

        FormalParameter formalparameter = null;
        String name = null;
        String type = null;

	if (isVersion0) {
	    name = getName(par);
	    if (name == null) {
		name = new String("");
	    }
	    if (exito) {
		type = getOperParameterType(par);
		if (exito) {
		    formalparameter = new FormalParameter(name, type);
		}
		else
		    System.out.println("Error: invalid operation parameter type");
	    }
	}
	else { // xmi version 1.1 or 1.2
	    NamedNodeMap atts = par.getAttributes();

	    Node item = atts.getNamedItem("name");
	    if (item != null) {
		name = item.getNodeValue().trim();
	    }
	    if ((item == null)|(name == null)) {
		name = new String("");
	    }
	    if (exito) {
		item = atts.getNamedItem("type");
		if (item == null) {
		Node typeNode  = searchChild(par, COREPREFIX + "Parameter.type");
		if (typeNode != null) {
		    // MagicDraw 9.5 uses a child node for UML standard profile types
		    Node classNode = searchChild(typeNode, COREPREFIX + "Classifier");
		    if (classNode != null) {
			Node extNode = searchChild(classNode, "XMI.extension");
			if (extNode != null) {
			    for (Node curNode = extNode.getFirstChild(); curNode != null & exito;
				 curNode = curNode.getNextSibling()) {
				if (curNode.getNodeName().equals("referentPath")) {
				    item = curNode.getAttributes().getNamedItem("xmi.value");
				    type = item.getNodeValue().trim();
				    if (type.startsWith("UML Standard Profile::"))
					type = type.substring(22);
				}
			    }
			}
		    }
		    else {
		        // Poseidon uses a child node, either Class or DataType
			classNode = searchChild(typeNode, CLASSTAGNAME);
			if (classNode == null) {
			    classNode = searchChild(typeNode, COREPREFIX + "DataType");
			}
			if (classNode != null) {
			    item = classNode.getAttributes().getNamedItem("xmi.idref");
			}
		    }
		    }
		}
		if (item != null) {
		    if (type == null) {
		        Document doc = parser.getDocument();
		        type = deRef(doc, item.getNodeValue().trim(), null);
		    }
		}
		else type = new String("");

		formalparameter = new FormalParameter(name, type);
                
	    }
	}       
        return formalparameter;

    }


    private static String getOperParameterType(Node node) {

        String type = null;
        Node child = searchChild(node, "Foundation.Core.Parameter.type");

        if (child != null)
            type = getType(child);
        else
            type = new String("");

        return type;

    }
        
   
    private static String getType(Node refNode) {
        
        String type = null;

            refNode = refNode.getFirstChild(); // get text
            if (refNode != null) {
                refNode = refNode.getNextSibling(); // get node with xmi.idref attribute
                if (refNode != null) {
                   NamedNodeMap node_attributes = refNode.getAttributes();
                   if (node_attributes != null) {
                        Node item = node_attributes.getNamedItem("xmi.idref");
                        if (item != null) {
                            Document doc = parser.getDocument();
                            type = deRef(doc, item.getNodeValue().trim(), null);
                            if (type == null){
                                exito = false;
                                System.out.println("Error: Invalid reference in type");
                            }
                        }
                        else 
                            exito =false;
                   }    
                   else 
                       exito = false;
                }
                else
                    exito = false;
            }
            else
                exito = false;
            
        return type;
            
    }


    private static String  getOperResult(Node op) {
        
        String result = null;
        boolean found = false;
	String kind;
        Node behavioralNode = searchChild(op, COREPREFIX + "BehavioralFeature.parameter");

        if (behavioralNode != null) {
            for (Node parameterNode = behavioralNode.getFirstChild(); 
                 parameterNode != null  & !found & exito; parameterNode = parameterNode.getNextSibling()) {
                if (parameterNode.getNodeName().equals(COREPREFIX + "Parameter")) {
		    if (isVersion0) {
			kind = getKind(parameterNode);
		    }
		    else { // xmi version 1.1 or 1.2
		    Node item = parameterNode.getAttributes().getNamedItem("kind");
		    if (item == null) {
			// MagicDraw kind defaults to "inout"
			kind = new String("inout");
		    }
		    else kind = item.getNodeValue().trim();
		    }
                    if (kind != null) {
                        if (kind.equals("return")){
                            found = true;
                            result = getOperResultType(parameterNode);
                        }
                    }
                    else
                        exito = false;
                }
            }
            if (!found)
                 result = new String("");
        }
        else 
            result = new String("");
        
        return result;
    }


    private static String getOperResultType(Node par) {

        String type = null;

	if (isVersion0) {
        Node child = searchChild(par, "Foundation.Core.Parameter.type");

        if (child != null)
            type = getType(child);
        else
            type = new String("");
	}
	else { // xmi version 1.1 or 1.2
	    Node item;

	    item = par.getAttributes().getNamedItem("type");
	    if (item == null) {
		// MagicDraw 9.5 uses a child node for UML standard profile types
		Node typeNode  = searchChild(par, COREPREFIX + "Parameter.type");
		if (typeNode != null) {
		    // For MagicDraw
		    Node classNode = searchChild(typeNode, COREPREFIX + "Classifier");
		    if (classNode != null) {
			Node extNode = searchChild(classNode, "XMI.extension");
			if (extNode != null) {
			    for (Node curNode = extNode.getFirstChild(); curNode != null & exito;
				 curNode = curNode.getNextSibling()) {
				if (curNode.getNodeName().equals("referentPath")) {
				    item = curNode.getAttributes().getNamedItem("xmi.value");
				    type = item.getNodeValue().trim();
				    if (type.startsWith("UML Standard Profile::"))
					type = type.substring(22);
				}
			    }
			}
		    }
		    else {
		    // Poseidon uses a child node, either Class or DataType
		    classNode = searchChild(typeNode, CLASSTAGNAME);
		    if (classNode == null) {
			classNode = searchChild(typeNode, COREPREFIX + "DataType");
		    }
		    if (classNode != null) {
			item = classNode.getAttributes().getNamedItem("xmi.idref");
		    }
		    }
		}
	    }
	    if (item != null) {
		if (type == null) {
		    Document doc = parser.getDocument();
		    type = deRef(doc, item.getNodeValue().trim(), null);
		}
	    }
	    else
		type = new String("");
	}
	return type;
    }

        
    private static boolean getIsAbstractOper(Node op) {
        
        boolean is_abstract = false;
        Node item;

	if (isVersion0) {
	    NamedNodeMap node_attributes;
	    Node isAbstractNode = searchChild(op, "Foundation.Core.Operation.isAbstract");
	    if (isAbstractNode != null) {
		node_attributes = isAbstractNode.getAttributes();
		if (node_attributes != null) {
		    item = node_attributes.getNamedItem("xmi.value");
		    if (item == null)
			exito = false;
		    else { 
			if (item.getNodeValue().trim().toLowerCase().equals("true"))
			    is_abstract = true;
		    }
		}
		else 
		    exito = false;
                
	    }
        
        if (!exito)
            System.out.println("Error: Foundation.Core.Operation.isAbstract without value");
	}
	else { // xmi version 1.1 or 1.2

	    item = op.getAttributes().getNamedItem("isAbstract");
	    if (item != null) {
		if (item.getNodeValue().trim().toLowerCase().equals("true"))
		    is_abstract = true;
	    }
	}   
        return is_abstract;

    }


    private static Multiplicity getClassMultiplicity(Node cl){
                
        // Class multiplicity processing should be here. 
        // Since Poseidon and Magic Draw do not allow to give it, multiplicity "*..*" is assumed.
        
        return new Multiplicity("*","*");

    }

    
    private static boolean getIs_abstract(Node cl){
        
        boolean is_abstract = false;
        Node item;

	if (isVersion0) {
	    Node typeNode = searchChild(cl, "Foundation.Core.GeneralizableElement.isAbstract");

	    if (typeNode != null) {
		item = typeNode.getAttributes().getNamedItem("xmi.value");
		if (item == null){
		    System.out.println("Error: Foundation.Core.GeneralizableElement.isAbstract sin valor");
		    exito = false;
		}
		else {
		    if (item.getNodeValue().trim().toLowerCase().equals("true"))
			is_abstract = true;
		}
	    }
	}
	else { // xmi version 1.1 or 1.2
	    item = cl.getAttributes().getNamedItem("isAbstract");
	    if (item != null) {
		if (item.getNodeValue().trim().toLowerCase().equals("true"))
		    is_abstract = true;
	    }
        }                
        return is_abstract;

    }


    private static boolean  getIs_root(Node cl){
        
        boolean is_root = false;        
        Node item;

	if (isVersion0) {
	    Node is_rootNode = searchChild(cl, "Foundation.Core.GeneralizableElement.isRoot");

	    if (is_rootNode != null) {
		item = is_rootNode.getAttributes().getNamedItem("xmi.value");
		if (item == null){
		    System.out.println("Error: Foundation.Core.GeneralizableElement.isRoot without value");
		    exito = false;
		}
		else{ 
		    if (item.getNodeValue().trim().toLowerCase().equals("true")) 
			is_root = true;
		}
	    }
	}
	else { // xmi version 1.1 or 1.2
	    item = cl.getAttributes().getNamedItem("isRoot");
	    if (item != null) {
		if (item.getNodeValue().trim().toLowerCase().equals("true")) 
		    is_root = true;
	    }
	}
        return is_root;

    }


    private static boolean  getIs_leaf(Node cl){

        boolean is_leaf = false;        
        Node item;

	if (isVersion0) {
	    Node is_leafNode = searchChild(cl, "Foundation.Core.GeneralizableElement.isLeaf");

	    if (is_leafNode != null) {
		item = is_leafNode.getAttributes().getNamedItem("xmi.value");
		if (item == null) {
		    System.out.println("Error: Foundation.Core.GeneralizableElement.isLeaf without value");
		    exito = false;
		}
		else{ 
		    if (item.getNodeValue().trim().toLowerCase().equals("true") ) 
			is_leaf  = true;
		} 
	    }
	}
	else { // xmi version 1.1 or 1.2
	    item = cl.getAttributes().getNamedItem("isLeaf");
	    if (item != null) {
		if (item.getNodeValue().trim().toLowerCase().equals("true")) 
		    is_leaf  = true;
	    }
	}
        return is_leaf;

    }


    private static Vector<FormalParameter> getClassParameters(Node cl){
        
        Vector<FormalParameter> parameters = new Vector<FormalParameter>(5,1);
        FormalParameter templateparameter;
        Node parametersNode = searchChild(cl, COREPREFIX + "ModelElement.templateParameter");

        if (parametersNode != null) {
            for (Node curNode = parametersNode.getFirstChild(); curNode != null & exito ; 
                 curNode = curNode.getNextSibling()) {
                if  (curNode instanceof Element) {
		    if (isVersion0) {
			if (curNode.getNodeName().equals("Foundation.Core.TemplateParameter")) {
			    templateparameter = getClassParameter(curNode);
			    if (exito)
				parameters.addElement(templateparameter);
			}
		    }
		    else { // xmi version 1.1 or 1.2
			if (curNode.getNodeName().equals(COREPREFIX + "TemplateParameter")) {
			    Node parameterNode1 = searchChild(curNode, COREPREFIX + "TemplateParameter.parameter");
			    Node parameterNode2 = searchChild(parameterNode1, COREPREFIX + "Parameter");
			    templateparameter = getClassParameter(parameterNode2);
			    if (exito)
				parameters.addElement(templateparameter);
			}
		    }
                }   
            }
        }

        return parameters;

    }
    

   private static FormalParameter getClassParameter(Node par) {

        FormalParameter formalparameter = null;
        String name;
        String type;

        name = getName(par);
        if (name == null) {
            exito = false;
            System.out.println("Error: Template parameter without name");
        }
        if (exito) {
            type = getTemplateParameterType(par);
            if (exito) 
                formalparameter = new FormalParameter(name, type);
            else
                System.out.println("Error: invalid template parameter type");
        }
        
        return formalparameter;

    }

 
    private static String getTemplateParameterType(Node node) {

        String type = null;

	if (isVersion0) {
	    Node child = searchChild(node, "Foundation.Core.TemplateParameter.parameter");

	    if (child != null)
		type = getType(child);
	    else
		type = new String("");
	}
	else { // xmi version 1.1 or 1.2
        Node item = node.getAttributes().getNamedItem("type");

        if (item != null) {
	    Document doc = parser.getDocument();
	    type = deRef(doc, item.getNodeValue().trim(), null);
	}
        else
            type = new String("");
	}
        return type;

    }
        
   
    private static void  processAssociations(Node node){

        for (Node curNode = node.getFirstChild(); curNode != null & exito ; 
             curNode = curNode.getNextSibling()) {
            if  (curNode instanceof Element) {
                if (curNode.getNodeName().equals(COREPREFIX + "Association"))
                   processAssociation(curNode);
            }
        }

    }


    private static void  processAssociation(Node asso){

        String association_name;
        Vector<End> ends;
        Association association;

        association_name = getName(asso);
        if (association_name == null) { 
            exito = false;
            System.out.println("Error: association without name");
        }
        if (exito) {
            ends = getEnds(asso);
            if (exito) {
                association = new Association(association_name, association_name, ends);
                cd.relations.addElement(association);
	    }
        }
                

    }


    private static Vector<End> getEnds(Node asso){
        
        End end;
        Vector<End> ends = new Vector<End>(3,1);
        Node curNode = searchChild(asso, COREPREFIX + "Association.connection");

        if (curNode != null) {
            for (curNode = curNode.getFirstChild(); curNode != null  & exito; 
                 curNode = curNode.getNextSibling()) {
                if (curNode.getNodeName().equals(COREPREFIX + "AssociationEnd")) { 
                    end = getEnd(curNode);
                    if (exito)
                        ends.addElement(end);
                }
            }
        }

        return ends;

    }


    private static End getEnd(Node end){
    
        Clase end_class;
        String role_name;
        Multiplicity multiplicity;
        boolean navigable;
        String kind;
        String changeability;
        int ch = CHANGEABLE;
        End e = null;

        end_class = getEnd_class(end);
        if (exito) {
            role_name = getName(end);
            if (exito) {
                if (role_name == null)
                    role_name = new String("");
                multiplicity = getAssocMultiplicity(end);
                if (exito) {
                    navigable = getNavigable(end);
                    if (exito) {
                        kind = getAggregationKind(end);
                        if (exito){
                            changeability = getEndChangeability(end);
                            if (exito) {
                                if (changeability.toLowerCase().trim().equals("frozen"))
                                    ch = FROZEN;
                                else {
                                    if (changeability.toLowerCase().trim().equals("addonly"))
                                        ch = ADDONLY;
                                }
                                e = new End(end_class, role_name, role_name, multiplicity, navigable,
                                            kind, ch);
                            }
                        }
                    }
                }
            }
        }

        return e;    

    }
    

    private static Clase getEnd_class(Node end) {

        Clase end_class = null;

	if (isVersion0) {
	    Node refNode = searchChild(end, "Foundation.Core.AssociationEnd.type");
        
	    if (refNode != null) {
		String classname = getType(refNode);
		end_class = cd.getClase(classname);
		if (end_class == null) {
		    exito = false;
		    System.out.println("Error: invalid class reference in association end.");
		}
	    }
	    else {
		exito = false;
		System.out.println("Error: Association end without reference to any class.");
	    }
	}
	else { // xmi version 1.1 or 1.2
	    Node item = null;
        
	    item = end.getAttributes().getNamedItem("participant");
	    if (item == null) {
		// Poseidon uses a child node
		Node participantNode  = searchChild(end, COREPREFIX + "AssociationEnd.participant");
		if (participantNode != null) {
		    Node classNode = searchChild(participantNode, CLASSTAGNAME);
		    if (classNode != null) {
			item = classNode.getAttributes().getNamedItem("xmi.idref");
		    }
		}
	    }
	    if (item != null) {
		Document doc = parser.getDocument();
		String classname = deRef(doc, item.getNodeValue().trim(), null);
		end_class = cd.getClase(classname);
		if (end_class == null) {
		    exito = false;
		    System.out.println("Error: invalid class reference in association end.");
		}
	    }
	    else {
		exito = false;
		System.out.println("Error: Association end without reference to any class.");
	    }
        }
        return end_class;

    }


    private static Multiplicity getAssocMultiplicity(Node end) {


        Multiplicity  multiplicity = null;
        Node curNode  = searchChild(end, COREPREFIX + "AssociationEnd.multiplicity");

        if (curNode != null) {
            multiplicity = getMultiplicity(curNode);
            if ( multiplicity.upper.equals("-1")) {
                if (multiplicity.lower.equals("-1"))
                    multiplicity = new Multiplicity("*","*");
                else
                    multiplicity = new Multiplicity(multiplicity.lower,"*");
            }
        }           
        else     
           multiplicity = new Multiplicity("1","1");

        return multiplicity;

    }


    private static boolean getNavigable(Node node){
        
        boolean is_navigable = false;

	if (isVersion0) {
	    Node navigable_node = searchChild(node, "Foundation.Core.AssociationEnd.isNavigable");

	    if (navigable_node != null) {
		Node item = navigable_node.getAttributes().getNamedItem("xmi.value");
		if (item == null) {
		    System.out.println("Error: Foundation.Core.AssociationEnd.isNavigable without value");
		    exito = false;
		}
		else{ 
		    if (item.getNodeValue().trim().toLowerCase().equals("true")) 
			is_navigable = true;
		} 
	    }
	}
	else { // xmi version 1.1 or 1.2
	    Node item = node.getAttributes().getNamedItem("isNavigable");

	    if (item != null) {
		if (item.getNodeValue().trim().toLowerCase().equals("true")) 
                    is_navigable = true;
	    }
	    // Magicdraw 7.5 defaults to no isNavigable node when not navigable
	}
        return is_navigable;
    }


    private static String getAggregationKind(Node node){
        
        String kind = null;

	if (isVersion0) {
	    Node kind_node = searchChild(node, "Foundation.Core.AssociationEnd.aggregation");

	    if (kind_node != null) {
		Node item = kind_node.getAttributes().getNamedItem("xmi.value");
		if (item == null) {
		    System.out.println("Error: Foundation.Core.AssociationEnd.aggregation without value");
		    exito = false;
		}
		else
		    kind  = new String(item.getNodeValue().trim().toLowerCase()); 
	    }
	}
	else { // xmi version 1.1 or 1.2
	    Node item = node.getAttributes().getNamedItem("aggregation");

	    if (item != null) {
		kind  = new String(item.getNodeValue().trim().toLowerCase()); 
	    }
	}

	if (kind == null) 
	    kind  = new String("none");
        return kind;
    }

    private static String getEndChangeability(Node node){
        
        String changeability = null;

	if (isVersion0) {
	    Node changeability_node = searchChild(node, "Foundation.Core.AssociationEnd.changeability");

	    if (changeability_node != null) {
		Node item = changeability_node.getAttributes().getNamedItem("xmi.value");
		if (item == null) {
		    System.out.println("Error: Foundation.Core.AssociationEnd.changeability without value");
		    exito = false;
		}
		else
		    changeability  = new String(item.getNodeValue().trim().toLowerCase()); 
	    }
	}
	else { // xmi version 1.1 or 1.2
	    Node item = node.getAttributes().getNamedItem("changeability");

	    if (item != null) {
		changeability  = new String(item.getNodeValue().trim().toLowerCase()); 
	    }
	}
        if (changeability == null) 
            changeability  = new String("changeable");

        return changeability;
    }


    private static void  processDependencies(Node node){

        Dependency dependency;
        
        for (Node curNode = node.getFirstChild(); curNode != null & exito ; 
             curNode = curNode.getNextSibling()) {
            if  (curNode instanceof Element) {
                if (curNode.getNodeName().equals(COREPREFIX + "Dependency")){
                   dependency = getDependency(curNode);
                   if (exito)
                       cd.relations.addElement(dependency);
                }
            }
        }
    }


    private static Dependency  getDependency(Node dep){

        Clase source = null;
        Clase target = null;
        Dependency dependency = null;

	if (isVersion0) {
	    Node refNode = searchChild(dep, "Foundation.Core.Dependency.supplier");
        
	    if (refNode != null) {
		String classname = getType(refNode);
		source = cd.getClase(classname);
		if (source == null) {
		    exito = false;
		    System.out.println("Error: invalid subclass reference in dependency.");
		}
		else {
		    refNode = searchChild(dep, "Foundation.Core.Dependency.client");
		    if (refNode != null) {
			classname = getType(refNode);          
			target = cd.getClase(classname);
			if (target == null) {
			    exito = false;
			    System.out.println("Error: invalid client reference in dependency.");
			}
			else 
			    dependency = new Dependency(source,target);
		    }
		    else {
			exito = false;
			System.out.println("Error: dependency  without reference to any supplier.");
		    }
		}
	    }
	    else {
		exito = false;
		System.out.println("Error: dependency  without reference to any client.");
	    }
	}
	else { // xmi version 1.1 or 1.2
	    NamedNodeMap node_attributes = dep.getAttributes();
	    Node item = null;
        
	    if (node_attributes != null)
		item = node_attributes.getNamedItem("supplier");
	    if (item != null) {
		Document doc = parser.getDocument();
		String classname = deRef(doc, item.getNodeValue().trim(), null);
		source = cd.getClase(classname);
		if (source == null) {
		    exito = false;
		    System.out.println("Error: invalid subclass reference in dependency.");
		}
		else {
		    item = node_attributes.getNamedItem("client");
		    if (item != null) {
			classname = deRef(doc, item.getNodeValue().trim(), null);
			target = cd.getClase(classname);
			if (target == null) {
			    exito = false;
			    System.out.println("Error: invalid client reference in dependency.");
			}
			else 
			    dependency = new Dependency(source,target);
		    }
		    else {
			exito = false;
			System.out.println("Error: dependency  without reference to any client.");
		    }
		}
	    }
	    else {
		exito = false;
		System.out.println("Error: dependency  without reference to any supplier.");
	    }
	}  
        return dependency;
                
    }


    private static void  processGeneralizations(Node node){

        for (Node curNode = node.getFirstChild(); curNode != null & exito ; 
             curNode = curNode.getNextSibling()) {
            if  (curNode instanceof Element) {
                if (curNode.getNodeName().equals(COREPREFIX + "Generalization"))
                   processGeneralization(curNode);
            }
        }
    }


    private static void  processGeneralization(Node gen){

        Clase subclass = null;
        Clase superclass = null;
        Generalization generalization;
	if (isVersion0) {
	    Node refNode = searchChild(gen, "Foundation.Core.Generalization.child");
        
	    if (refNode != null) {
		String classname = getType(refNode);
		subclass = cd.getClase(classname);
		if (subclass == null) {
		    exito = false;
		    System.out.println("Error: invalid subclass reference in generalization.");
		}
		else {
		    refNode = searchChild(gen, "Foundation.Core.Generalization.parent");
		    if (refNode != null) {
			classname = getType(refNode);
			superclass = cd.getClase(classname);
			if (superclass == null) {
			    exito = false;
			    System.out.println("Error: invalid superclass reference in generalization.");
			}
			else {
			    generalization = new Generalization(subclass, superclass);
			    cd.relations.addElement(generalization);
			}
		    }
		    else {
			exito = false;
			System.out.println("Error: generalization  without reference to any superclass.");
		    }
		}
	    }
	    else {
		exito = false;
		System.out.println("Error: generalization  without reference to any subclass.");
	    }
	}
	else { // xmi version 1.1 or 1.2
	    NamedNodeMap node_attributes = gen.getAttributes();
	    Node item = null;

	    item = node_attributes.getNamedItem("child");
	    if (item == null) {
		// Poseidon uses a child node
		Node childNode  = searchChild(gen, COREPREFIX + "Generalization.child");
		if (childNode != null) {
		    Node classNode = searchChild(childNode, CLASSTAGNAME);
		    if (classNode != null) {
			item = classNode.getAttributes().getNamedItem("xmi.idref");
		    }
		}
	    }
	    if (item != null) {
		Document doc = parser.getDocument();
		String classname = deRef(doc, item.getNodeValue().trim(), null);
		subclass = cd.getClase(classname);
		if (subclass == null) {
		    exito = false;
		    System.out.println("Error: invalid subclass reference in generalization.");
		}
		else {
		    item = node_attributes.getNamedItem("parent");
		    if (item == null) {
			// Poseidon uses a child node
			Node parentNode  = searchChild(gen, COREPREFIX + "Generalization.parent");
			if (parentNode != null) {
			    Node classNode = searchChild(parentNode, CLASSTAGNAME);
			    if (classNode != null) {
				item = classNode.getAttributes().getNamedItem("xmi.idref");
			    }
			}
		    }
		    if (item != null) {
			classname = deRef(doc, item.getNodeValue().trim(), null);
			superclass = cd.getClase(classname);
			if (superclass == null) {
			    exito = false;
			    System.out.println("Error: invalid superclass reference in generalization.");
			}
			else {
			    generalization = new Generalization(subclass, superclass);
			    cd.relations.addElement(generalization);
			}
		    }
		    else {
			exito = false;
			System.out.println("Error: generalization  without reference to any superclass.");
		    }
		}
	    }
	    else {
		exito = false;
		System.out.println("Error: generalization  without reference to any subclass.");
	    }
	}       
    }

    
    private static void  processInstantiations(Node node){

        for (Node curNode = node.getFirstChild(); curNode != null & exito ; 
             curNode = curNode.getNextSibling()) {
            if  (curNode instanceof Element) {
                if (curNode.getNodeName().equals(COREPREFIX + "Binding"))
                   processInstantiation(curNode);
            }
        }

    }


    private static void  processInstantiation(Node bind){

        Vector<String> actualPars = null; 
        Instantiation instantiation;
        Dependency dep = getDependency(bind);

        if (exito) {
            actualPars = getActualPars(bind);
            if (exito) {
                instantiation = new Instantiation(dep.source, dep.target, actualPars);
                cd.relations.addElement(instantiation);
            }
        }
    }


    private static Vector<String> getActualPars(Node bind){

        String actualpar;
        NamedNodeMap node_attributes;
        Node item;
        Vector<String> apars = new Vector<String>(10,1);
        Document doc = parser.getDocument();
        Node argNode = searchChild(bind, COREPREFIX + "Binding.argument");

	if (isVersion0) {
	    if (argNode != null) {
		for (Node curNode = argNode.getFirstChild(); curNode != null & exito ; 
		     curNode = curNode.getNextSibling()) {
		    if  (curNode instanceof Element) {
			if (curNode.getNodeName().equals("Foundation.Core.TemplateArgument")){
			    boolean found = false;
			    for (Node curNode1 = curNode.getFirstChild(); curNode1 != null & exito & !found; 
				 curNode1 = curNode1.getNextSibling()) {
				if  (curNode1 instanceof Element) {
				    if (curNode1.getNodeName().equals("Foundation.Core.TemplateArgument.modelElement")){
					found = true;
					for (Node curNode2 = curNode1.getFirstChild(); curNode2 != null & exito; 
					     curNode2 = curNode2.getNextSibling()) {
					    if  (curNode2 instanceof Element) {
						node_attributes = curNode2.getAttributes(); // get node attributes
						item = node_attributes.getNamedItem("xmi.idref");
						if (item != null){
						    actualpar = deRef(doc, item.getNodeValue().trim(), null);
						    if (actualpar != null)
							apars.addElement(actualpar);
						    else {
							exito = false;
							System.out.println
							    ("Error: Invalid actual parameter in instantiated class.");
						    }
						}
						else {
						    exito = false;
						    System.out.println
							("Error: binding argument without value in instantiation.");
						}
					    }
					}
				    }
				}
			    }
			    if (!found) {
				exito = false;
				System.out.println("Error: binding argument without value in instantiation." +
						   "Foundation.Core.TemplateArgument.modelElement not found.");
			    }
			}
		    }
		}
	    }
	    else {
		exito = false;
		System.out.println("Error: Foundation.Core.Binding.argument not found.");
	    }
	}
	else { // xmi version 1.1 or 1.2
	    if (argNode != null) {
		boolean found = false;
		for (Node curNode = argNode.getFirstChild(); curNode != null & exito ; 
		     curNode = curNode.getNextSibling()) {
		    if  (curNode instanceof Element) {
			if (curNode.getNodeName().equals(COREPREFIX + "TemplateArgument")){
			    item = curNode.getAttributes().getNamedItem("modelElement");
			    if (item != null) {
				found = true;
				actualpar = deRef(doc, item.getNodeValue().trim(), null);
				if (actualpar != null)
				    apars.addElement(actualpar);
				else {
				    exito = false;
				    System.out.println("Error: Invalid actual parameter in instantiated class.");
				}
			    }
			    else {
				exito = false;
				System.out.println("Error: binding argument without value in instantiation.");
			    }
			}
		    }
		}
		if (!found) {
		    exito = false;
		    System.out.println("Error: binding argument without value in instantiation." + "modelElement not found.");
		}
	    }
	    else {
		exito = false;
		System.out.println("Error: UML:Binding.argument not found.");
	    }
        }    
        return apars;

    }
    

    private static Node searchChild(Node node, String name) {
        
        boolean found = false;
        Node curNode;

        for (curNode = node.getFirstChild(); curNode != null & !found ; curNode = curNode.getNextSibling()) 
            if (curNode instanceof Element) 
                if (curNode.getNodeName().equals(name))
                    found = true;
        
        if (found) 
            return curNode.getPreviousSibling();
        else 
            return null;
    }


    private static Node searchRef(Node node, String ref, Node nodeRef){
        
        for (Node curNode = node.getFirstChild(); curNode != null ; curNode = curNode.getNextSibling()) {
            nodeRef = searchRef(curNode, ref, nodeRef);
            if (curNode instanceof Element) 
                nodeRef =refToNode(curNode, ref, nodeRef);
        }

        return nodeRef;

    }


    private static Node refToNode(Node node, String ref, Node nodeRef){
        
        NamedNodeMap node_attributes = node.getAttributes();
        Node item;

        if (node_attributes != null) {
            item  = node_attributes.getNamedItem("xmi.id");
            if (item != null){
                if (item.getNodeValue().trim().equals(ref)) {
                    nodeRef = node;
                }
            }
                
        }
        
        return nodeRef;

    }


    private static String deRef(Node node, String ref, String deref){
        
        for (Node curNode = node.getFirstChild(); curNode != null & exito; curNode=curNode.getNextSibling()){
            deref = deRef(curNode, ref, deref);
            if (curNode instanceof Element) 
                deref = refToString(curNode, ref, deref);
        }

        return deref;

    }


    private static String refToString(Node node, String ref, String deref){
        
        NamedNodeMap node_attributes = node.getAttributes();
        Node item;

        if (node_attributes != null) {
            item  = node_attributes.getNamedItem("xmi.id");
            if (item != null){
                if (item.getNodeValue().trim().equals(ref)) {
                    deref = getName(node);
                    if (deref == null) 
                        exito = false;
                }
            }
        }
        
        return deref;

    }

    public static boolean isaRSLtype(String s) {

        return (s.equals("Bool") | s.equals("Char") |s.equals("Int") |s.equals("Nat") |s.equals("Real") |
                s.equals("Text") | s.equals("Unit"));
    }
}

/*=======================================================================================================*/

class Clase{

    String name;
    Vector<Attribute> attributes;
    Vector<Operation> operations;
    Multiplicity  multiplicity;
    boolean is_abstract;
    boolean is_root;
    boolean is_leaf;
    Vector<FormalParameter> parameters;

    final static int CHANGEABLE = 0;
    final static int FROZEN = 1;
    final static int ADDONLY = 2;

    public Clase(String nam, Vector<Attribute> atts, Vector<Operation> ops,
		 Multiplicity mult, boolean is_abs, 
                 boolean is_r, boolean is_l, Vector<FormalParameter> pars) {
        name = nam;
        attributes = atts;
        operations = ops;
        multiplicity = mult;
        is_abstract = is_abs;
        is_root = is_r;
        is_leaf = is_l;
        parameters = pars;
    }


    public void print(){
        System.out.println("CLASS");
        System.out.print("NAME:" + name);
        System.out.print(" MULTIPLICITY:" + multiplicity.lower + ".." + multiplicity.upper);
        if (is_abstract) System.out.print(" IS_ABSTRACT");
        if (is_root) System.out.print(" IS_ROOT");
        if (is_leaf) System.out.print(" IS_LEAF");
        System.out.println();
        printAttributes();
        printOperations();
        printParameters();
        System.out.println("=============================================================================");

    }


    public void printAttributes() {
        Attribute at;
        Iterator vItr = attributes.iterator();

        while (vItr.hasNext()) {
            at = (Attribute) vItr.next();
            at.print();
        }
    }


    public void printOperations() {
        Operation oper;
        Iterator vItr = operations.iterator();

        while (vItr.hasNext()) {
            oper = (Operation) vItr.next();
            oper.print();
        }
    }

    
    public void printParameters() {
        FormalParameter parameter;
        
        for (int i = 0 ; i < parameters.size(); i++){
            parameter = (FormalParameter) parameters.get(i);
	    System.out.print("par " + i + ":");
            parameter.print();
        }
    }


    public int isInParNames(String name) {

	// Return the position where name is in the formal parameter list. If name is not then returns -1.
        
        boolean isin = false;
        FormalParameter parameter;
	int i;
        
	for (i = 0; i < parameters.size() & !isin ; i++) {
            parameter = (FormalParameter) parameters.get(i);
            if (parameter.name.equals(name))
                isin = true;
        }
        
	if (isin)
	    return i-1;
	else
	    return -1;
    }

    public boolean validClassName() {

	// It checks if the class name is not an RSL keyword or it gives place to an RSL keyword
	
	RSLKeywordTable rslKeywordT = new RSLKeywordTable();
	boolean valid = true;

	if (rslKeywordT.contains(name)) {
	    valid = false;
	    System.out.println("Error: Invalid class name (RSL keyword " + name + ")");
	}
	else {
	    if (rslKeywordT.contains(name.toLowerCase()+"s")){
		valid = false;
		System.out.println("Error: Invalid class name " + name + ". It produces the RSL keyword " 
				   + name.toLowerCase()+ "s as an RSL record destructor.");
	    }
	    else
		if (rslKeywordT.contains(name + "s")) {
		valid = false;
		System.out.println("Error: Invalid class name " + name + ". It produces the RSL keyword " 
				   + name + "s as an RSL type.");
	    }
	}
	    
	return valid;   
    }
 

    public boolean validAtts(){

        // This method checks for any attribute: 

        // 1) valid attribute multiplicity;
        // 2) addonly attribute changeability used only with attributes not fixed multiplicities greater than 1;
        // 3) there are no duplicated attribute names.
	// 4) valid attribute name (It cannot be an RSL keyword).
	// 5) valid attribute type (It cannot be an RSL keyword, except an RSL type).
        
        
        Attribute at, at1;
        boolean valid = true;
        
        for (int j = 0; j < attributes.size(); j++) {  //iterates on attributes
            at = (Attribute) attributes.get(j);
            //1
            if (!at.multiplicity.valid(this)) {  
                valid = false;
                System.out.println("Error: Invalid  multiplicity in attribute \"" 
                                   + at.name + "\" in class \"" + name + "\".");
            }
            //2
            if (at.changeability == ADDONLY & 
		(at.multiplicity.upper.equals("1") | at.multiplicity.upper.equals("0") | 
		   (Multiplicity.allDigits(at.multiplicity.upper) & at.multiplicity.upper.equals(at.multiplicity.lower)))){   
                valid = false;
                System.out.println("Error: Inconsistent multiplicity and changeability in attribute \"" 
				   + at.name + "\" in class \"" + name + "\".");
            }
            //3
            for (int k = j + 1 ; k < attributes.size() & valid; k++) {
                at1 = (Attribute) attributes.get(k);
                if (at1.name.equals(at.name)) {
                    valid = false;
                    System.out.println("Error: Duplicate attribute name \"" 
                                       + at.name + "\" in class \"" + name + "\".");
                }
            }
	    //4
	    RSLKeywordTable rslKeywordT = new RSLKeywordTable();
	    if (rslKeywordT.contains(at.name)) {
		valid = false;
		System.out.println("Error: Invalid attribute name (RSL keyword " + at.name + ") in class " + name + ".");
	    }
	    //5
	    if (rslKeywordT.contains(at.type) & !UML2RSL.isaRSLtype(at.type)) {
		valid = false;
		System.out.println("Error: Invalid attribute type (RSL keyword " + at.type + ") in attribute " +
				   at.name + " in class " + name + ".");
	    }
	}

	return valid;
    }

    public  boolean validOps() {
        
        // This method checks for any operation in a class:

        // 1) abstract operation belongs to an abstract class.
	// 2) valid operation name (It checks if the operation name is not an RSL keyword).
        // 3) operations with common names and scope must differ in the parameters or in the result.
	// 4) operation parameter types cannot be an RSL keyword (except an RSL type).
	// 5) operation result type cannot be an RSL keyword (except an RSL type).
        
        Operation op, op1;
        boolean valid = true;
        
        for (int i = 0; i < operations.size() ; i++) {  //iterates on operations
            op = (Operation) operations.get(i);

            // 1
            if (op.is_abstract & !is_abstract) {
                valid = false;
                System.out.println("Error: abstract operation \"" + op.name +
                                               "\" in concrete class \"" + name + "\".");
            }

	    // 2
	    RSLKeywordTable rslKeywordT = new RSLKeywordTable();
	    if (rslKeywordT.contains(op.name)) {
		valid = false;
		System.out.println("Error: Invalid operation name (RSL keyword " + op.name + " ) in class " + name + ".");
	    } 
	    

            //3 
            for (int j = i + 1 ; j < operations.size() & valid ; j++) {
                op1 = (Operation) operations.get(j);
                if (op.name.equals(op1.name) & op.scope.equalsIgnoreCase(op1.scope)) {
                      if (op.result.equals(op1.result) & 
                          op.fpsEqualTypes(op.formalparameters, op1.formalparameters)){
                          valid = false;
                          System.out.println("Error: Duplicate operation name (" + op.name + ").");
                      }
                }
            }

	    //4
	    for (int j = 0 ; j < op.formalparameters.size() ; j++) {
		FormalParameter fp = (FormalParameter) op.formalparameters.get(j);
		if (fp.type.equals("")) {
		    if (fp.name.equals("")) {
			// Op. Parameter without name or type
			valid = false;
			System.out.println("Error: Operation " + op.name + " in class " + name + " has parameter with neither name or type.");
		    } else {
			// Op. parameter name without type. The name will be translated as an RSL sort.
			if (rslKeywordT.contains(fp.name)& !UML2RSL.isaRSLtype(fp.name)) {
			    valid = false;
			    System.out.println("Error: Invalid operation parameter name (RSL keyword " + fp.name + 
					   " ) in operation " + op.name + " in class " + name + ".");
			    }
			}
		} else {
		    // Op. parameter name with type. The name is ignored, only the type  will be translated as an RSL sort.
		    if (rslKeywordT.contains(fp.type) & !UML2RSL.isaRSLtype(fp.type)) {
			valid = false;
			System.out.println("Error: Invalid operation parameter type (RSL keyword " + fp.type + 
					   " ) in operation " + op.name + " in class " + name + ".");
		    }
		}
	    }

	    //5
	    if (rslKeywordT.contains(op.result) & !UML2RSL.isaRSLtype(op.result)) {
		valid = false;
		System.out.println("Error: Invalid operation result type (RSL keyword " + op.result + 
				   " ) in operation " + op.name + " in class " + name + ".");
	    }
	}

        return valid;

    }
    
    public  boolean validIfAbstract() {
        
        // Abstract classes must have at least one abstract operation.
	
	boolean valid = false;
        
	if (is_abstract) {
	    for (int i = 0; i < operations.size() & !valid; i++) {  //iterates on operations
		Operation op = (Operation) operations.get(i);
		if (op.is_abstract) {
		    valid = true;
		}
	    }
	    if (!valid) 
		System.out.println("Error: abstract class \"" + name + "\" with no abstract operation.");
	}
	else
	    valid = true;
	
	return valid;
    }
     
    public  boolean validMult() {
        
        boolean valid = multiplicity.valid(null);

        if (!valid)
             System.out.println("Error: Invalid multiplicity in class \"" + name + "\".");

        return valid;
    }

    public  boolean validPars() {

	// It retuns true if:
	// 1) parameter names are not RSL keywords.
	// 2) parameters types are not RSL keywords (except RSL types).
	// 3) there are no duplicate parameter names in a template class. 

	RSLKeywordTable rslKeywordT = new RSLKeywordTable();
	boolean valid = true;
	FormalParameter fp,fp1;

	for (int i = 0 ; i < parameters.size() & valid ; i++) {  //iterates on parameters
            fp = (FormalParameter) parameters.get(i);
	    if (rslKeywordT.contains(fp.name)) {
		valid = false;
		System.out.println("Error: Invalid parameter name (RSL keyword " + fp.name + ")");
	    }
	     
	    if (rslKeywordT.contains(fp.type) & !UML2RSL.isaRSLtype(fp.type)) {
		valid = false;
		System.out.println("Error: Invalid class parameter type (RSL keyword " + fp.type + 
				   " ) in class " + name + ".");
	    }
	    
            for (int j = i + 1 ; j < parameters.size() & valid ; j++) {
                fp1 = (FormalParameter) parameters.get(j);
                if (fp.name.equals(fp1.name)) {
		    System.out.println("Error: Duplicated parameter name in template class \"" + name + "\".");
		    valid = false;
		}
            }
        }
	
	return valid;
    }
    

    public boolean isLeaf(){ 

        return is_leaf;

    }

    public boolean isAbstract(){ 

        return is_abstract;

    }

   
    public boolean isTemplate(){ 

        return parameters.size() != 0;

    }

       
    public Vector<Operation> getOperations(String scope) {

        Vector<Operation> ops = new Vector<Operation>(10,1);
        Operation op;

        for (int i = 0 ; i < operations.size() ; i++) {
            op = (Operation) operations.get(i);
            if (op.scope.equals(scope))
                ops.addElement(op);
        }

        return ops;
    }

}

/*=======================================================================================================*/

class Attribute {

    String name;
    String alias;
    String type;
    Multiplicity multiplicity;
    String scope;
    int changeability;

    public Attribute(String nam, String al, String at, Multiplicity mul, String sc, int ch){

        name = nam;
        alias = al;
        type = at;
        multiplicity = mul;
        scope = sc;
        changeability = ch;
        

    }
    public void print() {

        System.out.println("ATRIBUTE");
        System.out.print("NAME:" + name);
        System.out.print(" TYPE:" + type);
        System.out.print(" MULTIPLICITY:" + multiplicity.lower + ".." + multiplicity.upper);
        System.out.print(" SCOPE:" + scope);
        System.out.println(" CHANGEABILITY:" + changeability);

    }
        
}

/*=======================================================================================================*/

class Operation {

    String name;
    String alias;
    Vector<FormalParameter> formalparameters;
    String result;
    boolean is_abstract;
    String scope;

    public Operation(String nam, String al, Vector<FormalParameter> fp, String res, boolean is_abs, String sc){

        name = nam;
        alias = al;
        formalparameters = fp;
        result = res;
        is_abstract = is_abs;
        scope = sc;
    }
    
    public void print() {

        System.out.println("OPERATION");
        System.out.print(" NAME:" + name);
         System.out.print(" RESULT:" + result);
        if (is_abstract) System.out.print(" IS ABSTRACT");
        System.out.println(" SCOPE:" + scope);
        System.out.println("FORMAL PARAMETERS");
        printFormalParameters();
        
    }

    public void printFormalParameters(){

        FormalParameter fp;
        Iterator vItr = formalparameters.iterator();

        while (vItr.hasNext()) {
            fp = (FormalParameter) vItr.next();
            fp.print();
        }
    }


    public boolean fpsEqualTypes(Vector<FormalParameter> fps1, Vector<FormalParameter> fps2) {
        
        FormalParameter fp1, fp2;
        boolean eqT = true;

        if (fps1.size() != fps2.size()) 
	    eqT = false;
        else {
            for (int i = 0 ; i < fps1.size() & eqT ; i++) {
                fp1 = (FormalParameter) fps1.get(i);
                fp2 = (FormalParameter) fps2.get(i);
                if (!fp1.type.equals(fp2.type)) 
                    eqT = false;
		else {
		    if (fp1.type.equals("") & !fp1.name.equals(fp2.name))
			eqT = false;
		}
            }
        }

        return eqT;
    }


}


/*=======================================================================================================*/

class FormalParameter {
    
    String name;
    String type;
    
    public FormalParameter(String nam,  String ptyp) {

        name = nam;
        type = ptyp;

    }

    public void print(){
        
        System.out.print("PARAMETER NAME:" + name);
        System.out.println(" PARAMETER TYPE:" + type);

    }


}

/*=======================================================================================================*/

class Multiplicity {

    String lower;
    String upper;

    public Multiplicity(String lo, String up){

        lower = lo;
        upper = up;

    }

    public  boolean valid(Clase cl){

        // It validates attribute, class, and association end multiplicities. When the multiplicity
        // to be checked corresponds to an attribute, cl has the class that owns the attribute
        // since attributes may have parameterized multiplicities, otherwise  cl should be null.

        boolean valid = true;
	
        if (allDigits(lower)) {
            int l = Integer.parseInt(lower);
            if (l >= 0) {
                if (allDigits(upper)) {
                    int u = Integer.parseInt(upper);
                    if (u >= 0) 
                        valid =  l <= u;
                    else 
                        valid = false;
                }
                else {
                    if (upper.equals("*")) 
                        valid = true;
                    else {
                        // It checks if the upper bound is a class parameter (this is valid only 
			// when cl != null, i.e. when an attribute multiplicity is being checked). 
			if (cl != null) {
			    if (cl.isInParNames(upper) != -1)
				valid = true;
			    else
				valid = false;
			}
                        else 
                            valid = false;
                    }
                }
            }
            else valid = false;
        }
        else {
            if (lower.equals("*")) {
                if (upper.equals("*"))
                    valid = true;
                else 
                    valid = false;
            }
            else {
                if (cl != null){
		    // It checks if the lower and/or the upper bound are a class parameter 
		    // (this is valid only when cl != null, i.e. when an attribute multiplicity is
		    // being checked). 
                    
                    if (upper.equals("*")) {
			if (cl.isInParNames(lower) != -1)
			    valid = true;
			else
			    valid = false;
		    }
                    else {
			if (cl.isInParNames(lower) != -1 & lower.equals(upper))
			    valid = true; 
			else
			    valid = false;
		    } 
                }
                else
                    valid = false;
            }
        }
        
        return valid;

    }


    public static boolean allDigits(String s) {
        
        int i;
        boolean allDigits = true;
        
        try {
            i = Integer.parseInt(s);
        }
        catch (NumberFormatException e) {
            allDigits = false;
        }
        return allDigits;
        
    }


    public int getMult_type() {

        int mult_type = 2;    // many, i.e. any multiplicity different to 0..1 and 1..1

        if (upper.equals("1")) {
            if (lower.equals("0"))
                mult_type = 0;   // 0..1
            else {
                if (lower.equals("1"))
                    mult_type = 1;   // 1..1
            }
        }

        return mult_type;
    }

   
}


/*=======================================================================================================*/

class Association {

    String name;
    String alias;
    Vector<End> ends;

    public Association(String nam, String al, Vector<End> es){
        name = nam;
        alias = al;
        ends = es;
    }

    public void print() {

        System.out.println("ASSOCIATION NAME:" + name);
        System.out.println();
        printEnds();
        System.out.println("==============================================================================");
    }

   public void printEnds() {

        End end;
        Iterator vItr = ends.iterator();

        while (vItr.hasNext()) {
            end = (End) vItr.next();
            end.print();
        }
    }

    public boolean isinEnds(String classname) {

        boolean isin = false;
        End end;
        
        for (int i = 0 ; i < ends.size() & !isin ; i++) {
            end = (End) ends.get(i);
            if (end.end_class.name.equals(classname))
                isin = true;
        }

        return isin;
    }    

    public boolean isaTarget(String classname) {

        boolean isa = false;
        End end;

        for (int i = 0 ; i < ends.size() & !isa ; i++) {
            end = (End) ends.get(i);
            if (classname.equals(end.end_class.name) & end.navigable)
                isa = true;
        }
        
        return isa;

    } 

    public  boolean isaSource(String classname) {

        boolean isa = false;
        End end, end1;

        for (int i = 0 ; i < ends.size() & !isa ; i++) {
            end = (End) ends.get(i);
            if (classname.equals(end.end_class.name)) {
                for (int j = 0 ; j < ends.size() & !isa; j++) {
                    end1 = (End) ends.get(j);
                    isa = end1.navigable & !end1.end_class.name.equals(end.end_class.name);
                }
            }
        }
        
        return isa;

    }


    public End getWholeEnd() {

        End whole = null;
        
        for (int i = 0 ; i < ends.size() & whole == null ; i++) {
            End end = (End) ends.get(i);
            if (end.kind.equals("composite"))
                whole = end;    
        }
        
        return whole;

    }


    public End getPartEnd() {

        End part = null;
        End whole  = getWholeEnd();

        if (whole != null) {
            for (int i = 0 ; i < ends.size() &  part == null ; i++) {
            End end = (End) ends.get(i);
            if (!end.kind.equals("composite"))
                 part = end;    
            }
        }
        
        return part;
    }


    public boolean existsNavigableEnd() {

	boolean exists = false;

	for (int i = 0; i < ends.size() & !exists ; i++) {
	    End end = (End) ends.get(i);
	    if (end.navigable)
		exists = true;
	}

	return exists;

    }


    public boolean existsMoreThanOneAggr() {

	boolean exists = false;

	for (int i = 0; i < ends.size() & !exists ; i++) {
	    End end1 = (End) ends.get(i);
	    if (!end1.kind.equals("none")) // aggregate or composite
		for (int j = 0; j < ends.size() & !exists ; j++) {
		    if (j != i){
			End end2 = (End) ends.get(j);
			if (!end2.kind.equals("none"))
			    exists = true;
		    }
		}
	}

	return exists;

    }

}

/*=======================================================================================================*/

class Dependency{

    Clase source;
    Clase target;

    public Dependency(Clase sor, Clase tar){
        source = sor;
        target = tar;
    }


    public void print() {
        
        System.out.println("DEPENDENCY");
        System.out.println("CLIENT:" + source.name + " SUPPLIER:" + target.name);
        System.out.println("==============================================================================");

    } 

}
/*=======================================================================================================*/

class Generalization {

    Clase subclass;
    Clase superclass;


    public Generalization(Clase sub, Clase sup){

        subclass = sub;
        superclass = sup;

    }

    public void print() {
        
        System.out.println("GENERALIZATION");
        System.out.println("SUBCLASS:" + subclass.name + " SUPERCLASS:" + superclass.name);
        System.out.println("==============================================================================");

    } 

    public boolean redefineAtts() {

	boolean redef = false;

	for (int i = 0 ; i < subclass.attributes.size() & !redef; i++) {
	    Attribute at1 = (Attribute) subclass.attributes.get(i);
	    for (int j = 0; j < superclass.attributes.size() & !redef; j++) {
		Attribute at2 = (Attribute) superclass.attributes.get(j);
		if (at1.name.trim().equals(at2.name.trim()))
		    redef = true;
	    }
	}

	return redef;
    }

}

/*=======================================================================================================*/

class Instantiation{

    Clase template;
    Clase instantiated;
    Vector<String> actualParameters;

    public Instantiation(Clase tem, Clase ins, Vector<String> actualpars){

        template = tem;
        instantiated = ins;
        actualParameters = actualpars;

    }

    public void print() {
        
        System.out.println("INSTANTIATION");
        System.out.println("TEMPLATE:" + template.name + " INSTANTIATED:" + instantiated.name);
        System.out.println("PARAMETERS");
        printActualParameters();
        System.out.println("==============================================================================");

    } 

    public void printActualParameters(){

        String ap;
        Iterator vItr = actualParameters.iterator();

        while (vItr.hasNext()) {
            ap = (String) vItr.next();
            System.out.print(ap + " ");
        }
        System.out.println();
    } 

}

/*=======================================================================================================*/

class End{

    Clase end_class;
    String role_name;
    String alias;
    Multiplicity multiplicity;
    boolean navigable;
    String kind;
    int changeability;

    public End(Clase ec, String rn, String al, Multiplicity mul, boolean nav, String kin, int ch){

        end_class = ec;
        role_name = rn;
        alias = al;
        multiplicity = mul;
        navigable = nav;
        kind = kin;
        changeability = ch;

    }
    
    public void print(){

        System.out.print("END CLASS:"+ end_class.name);
        System.out.print(" ROLENAME:"+ role_name);
        System.out.print(" MULTIPLICITY:" + multiplicity.lower + ".." + multiplicity.upper);
        if (navigable) System.out.print(" IS NAVIGABLE");
        else System.out.print(" IS NOT NAVIGABLE");
        System.out.println(" KIND:" + kind);
        System.out.println(" CHANGEABILITY:" + changeability);
    }


}

/*=======================================================================================================*/

class ClassDiagram{

    Vector<Clase> classes;
    Vector<Object> relations;
    
    final static int MODULENAME = 0;
    final static int RECORDFIELD = 1;
    final static int CHANGEABLE = 0;
    final static int FROZEN = 1;
    final static int ADDONLY = 2;
    final static int COMPO = 0;
    final static int ASSO = 1;

    public ClassDiagram(Vector<Clase> cls, Vector<Object> rels) {

        classes = cls;
        relations = rels;

    }


    public Clase getClase(String classname) {

        Clase clase = null;
        boolean found = false;
        Iterator vItr = classes.iterator();

        while (vItr.hasNext() & !found) {
            clase = (Clase) vItr.next();
            if (clase.name.trim().equals(classname.trim())) 
                found = true;
        }
        if (!found)
            clase = null;

        return clase;

    }

    
    public  void  print(){
     
        Clase clase;
        Object o;
        Iterator vItr = classes.iterator();

        while (vItr.hasNext()) {
            clase = (Clase) vItr.next();
            clase.print();
        }

        vItr = relations.iterator();
        while (vItr.hasNext()) {
            o =vItr.next();
            if (o instanceof Association) 
                ((Association)o).print();
            else {
                if (o instanceof Generalization) 
                    ((Generalization)o).print();
                else {
                    if (o instanceof Dependency) 
                        ((Dependency)o).print();
                    else 
                        ((Instantiation)o).print();
                }
            }
        }
        
    }


    /*  ===================================================================== */                     
    /*                Methods used to validate a class diagram             */
    /*  ===================================================================== */    

 
    public boolean wellFormed(){

        Clase clase;
        Object o;
        boolean wellformed = true;
        Association association;
        Generalization generalization;
        Instantiation instantiation;

        
        for (int i = 0 ; i < classes.size() ; i++) {   //iterates on classes
            clase = (Clase) classes.get(i);
            if (!validClass(clase, i))
                wellformed = false;
	}
	for (int i = 0 ; i < relations.size() & wellformed ; i++) {   //iterates on relations
            o =  relations.get(i);
            if (o instanceof Association) {
                association = (Association) o;
                if (!validAsso(association, i))
                    wellformed = false;
	    }
            else {
                if (o instanceof Instantiation) {
                    instantiation = (Instantiation) o;
                    if (!validInst(instantiation, i))
                        wellformed = false;
                }
                else 
                    if (o instanceof Generalization) {
                        generalization = (Generalization) o;
                        if (!validGen(generalization, i))
                            wellformed = false;
                    }
            }
        }
	if (wellformed){
            if (existsGenLoop())
                wellformed = false;
            else {
		/* // When two classes are directly or transitively related by a generalization, only
                // general associations or compositions where the superclass is not the whole 
                // are allowed between them.
                if (!allowedInGeneralization())
		wellformed = false;*/
		// There are no two different instantiations for the same instantiated class.
		if (duplicatedInstantiations())
		    wellformed = false;
            }
        }
	            
        if (wellformed) 
            System.out.println("Well formed class diagram.");
        else
            System.out.println("Not well formed class diagram. Imposible to generate  RSL code.");

        return wellformed;
    }


    public boolean validClass(Clase clase, int pos) {

        return clase.validClassName() & clase.validAtts() & clase.validOps() & clase.validMult() & 
	    clase.validPars() &	clase.validIfAbstract() & !duplicatedClassName(clase.name, pos) & 
	    !isAbstractWithoutSubclass(clase);
    }


    public boolean validAsso(Association asso, int assoPos) {

        // It checks that an association is valid: 

        // 1) An association name cannot be an RSL keyword.
	// 2) An association is a N-ary relation with N >=2. 
        // 3) The multiplicity of each end must be valid.
        // 4) An aggregate end (aggregation or composition) cannot be part of a N-ary relation (N>2).
        // 5) A composite end cannot have a multiplicity greater than one.
        // 6) The parts of a composition must be navigable from the whole.
        // 7) "addOnly" association ends can be used only with multiplicities greater than 1.
	// 8) At least one end must be navigable.
	// 9) Only one end can be aggragated (aggregation or composition).
	// 10) There are no associations with the same name relating a common class.
	
 
        boolean valid = true;
        End end, end1;

	//1
	RSLKeywordTable rslKeywordT = new RSLKeywordTable();
	if (rslKeywordT.contains(asso.name)) {
	    System.out.println("Error: Invalid association name (RSL keyword " + asso.name + ").");
	    valid = false;
        }
	//2
        if (asso.ends.size() < 2) {
            System.out.println("Error: Association \"" + asso.name + 
                                   "\" is not well formed. It must have at least two ends.");
	    valid = false;
	}
        else {  
            for (int i = 0 ; i < asso.ends.size() ; i++) {
                end = (End) asso.ends.get(i);
                //3                             
                if (!end.multiplicity.valid(null)) {
                    valid = false;
                    System.out.println("Error: Invalid multiplicity in class \"" + 
                                       end.end_class.name + "\" in association \"" + asso.name + "\".");
                }

                //  It has no repeated rolenames. It is not necessary to check it because rolenames are
                //  not used. Instead of them, association names are used, with sufixes if it necessary.
                // 
                /*for (int j = i + 1 ; j < asso.ends.size() & valid ; j++) {
                    end1 = (End) asso.ends.get(j);
                    if (end.role_name.equals(end1.role_name) & !end.role_name.equals("")) {
                        valid = false;
                        System.out.println("Error: Duplicated rolename " + 
                                           end.role_name + " in association " + asso.name + ".");
                    }
                }*/

                //4
                if (!end.kind.equals("none")) {
                    if (asso.ends.size() != 2) {
                        valid = false;
                        System.out.println("Error: Not allowed aggregated end in N-ary association \""
                                           + asso.name + "\".");
                    }
                
                    else {
                        if (end.kind.equals("composite")) {
                            //5
                            if (!end.multiplicity.upper.equals("1")) {
                                valid = false;
                                System.out.println("Error: Not allowed multiplicity in composite end" +
                                                   " in association \"" + asso.name + "\".");
                            }

                            //6
                            if (i == 0) 
                                end1 = (End) asso.ends.get(1);
                            else 
                                end1 = (End) asso.ends.get(0);
                            if (!end1.navigable) {
                                valid = false;
                                System.out.println("Error: Composition with not navigable parts.");
                            }
			}
                    }
                }

                // 7
                if (end.changeability == ADDONLY & 
		    (end.multiplicity.upper.equals("1") | end.multiplicity.upper.equals("0") |
		    (Multiplicity.allDigits(end.multiplicity.upper) & 	
		     end.multiplicity.upper.equals(end.multiplicity.lower)))) {
                    valid = false;
                    System.out.println("Error: Inconsistent multiplicity and changeability in" +
                                       " association \"" + asso.name + "\" at the end corresponding to " +
                                       "the class \"" + end.end_class.name + "\".");
                }
            }
	    // 8
	    if (!asso.existsNavigableEnd()) {
		valid = false;
		System.out.println("Error: Associations must have at least one navigable end, and " +
				   "association \"" + asso.name + "\" has no one.");
	    }

	    // 9		
	    if (asso.existsMoreThanOneAggr()) {
		valid = false;
		System.out.println("Error: Association \"" + asso.name + "\" with more than one " +
				   "aggregated end.");
	    }
	    // 10
	    if (duplicatedAssocName(asso, assoPos)){
		valid = false;
		System.out.println("Error: Duplicated association name \"" + asso.name + "\"");
	    }
	}
	            
	return valid;

    }


    public boolean duplicatedClassName(String classname, int classPos) {

        boolean duplicated = false;
        Clase cl;
        
        for (int i = classPos + 1 ; i < classes.size() & !duplicated ; i++) {
            cl = (Clase) classes.get(i);
            if (classname.equals(cl.name)) {
                duplicated = true;
                System.out.println("Error: Duplicated class name \"" + classname + "\".");
            }
        }

        return duplicated;
            

    }
    

    public boolean isAbstractWithoutSubclass(Clase cl) {

	boolean error = false;
	
	if (cl.is_abstract & !isaSuperclass(cl)) {
	    System.out.println("Error: Abstract class \"" + cl.name + "\" without subclasses.");
	    error = true;
	}

	return error;
    }


    public boolean isaSuperclass(Clase cl) {

        boolean isa = false; 
        
	for (int i = 0 ; i < relations.size() & !isa; i++) {   //iterates on relations
	    Object o =  relations.get(i);
	    if (o instanceof Generalization) {
		Generalization gen = (Generalization) o;
		if (gen.superclass.equals(cl))
		     isa = true;
	    }
	}

	return isa;
    }


    public boolean duplicatedAssocName(Association asso, int assoPos) {

        // It checks if there are associations that having the same name relate a common class.

        boolean duplicated = false;
        Association association;
        Object o;
        
        for (int i = assoPos+1 ; i < relations.size() & !duplicated ; i++) {
            o  = relations.get(i);
            if (o instanceof Association) {
                association = (Association) o;
                if (asso.name.equals(association.name) & commonEndClass(asso.ends, association.ends)) {
                    duplicated = true;
		}
            }

        }

        return duplicated;
        
    }


    public Vector<Pair> getGeneralizations() {

        Object o;
        Generalization gen;
        Vector<Pair> gens = new Vector<Pair>();
        
        for (int i = 0 ; i < relations.size() ; i++) {
            o = relations.get(i);
            if (o instanceof Generalization) {
                gen = (Generalization) o;
                gens.addElement(new Pair(gen.subclass.name, gen.superclass.name));
            }
        }

        return gens;
        
    }

    public Vector<Pair> getInstantiations() {

        Object o;
        Instantiation ins;
        Vector<Pair> inss = new Vector<Pair>();
        
        for (int i = 0 ; i < relations.size() ; i++) {
            o = relations.get(i);
            if (o instanceof Instantiation) {
                ins = (Instantiation) o;
                inss.addElement(new Pair(ins.instantiated.name, ins.template.name));
            }
        }

        return inss;
        
    }

    public boolean existsGenLoop() {
	
        boolean exist = false;
        Pair p;
        Vector<Pair> gens = union(getGeneralizations(), getInstantiations());
        closure(gens);
	
        if (existsSimetricPairs(gens)| existsReflexivePairs(gens)) {
	    exist = true;
	    System.out.println("Error: Loop among generalization relations.");
	}
	
	return exist;
	
    }


    public boolean existsSimetricPairs(Vector<Pair> r) {

	boolean exist = false;
        
	for (int i = 0 ; i < r.size() & !exist; i++) {
	    Pair p1 = (Pair) r.get(i);
	    for (int j = i+1 ; j < r.size() & !exist; j++) {
		Pair p2 = (Pair) r.get(j);
		if (p1.c1.equals(p2.c2) & p1.c2.equals(p2.c1))
		    exist = true;
	    }
	}

	return exist;

    }
      

    public boolean existsReflexivePairs(Vector<Pair> r) {
        
        boolean exist = false;

        for (int i = 0 ; i < r.size() & !exist ; i++) {
            Pair p = (Pair) r.get(i);
            if (p.c1.equals(p.c2))
                exist = true;
        }

        return exist;

    }


    public boolean allowedInGeneralization() {

        boolean allowed = true;
        
        for (int i = 0 ; i < classes.size() & allowed; i++) {
            Clase c1 = (Clase) classes.get(i);
            for (int j = 0 ; j < classes.size() & allowed; j++) {
                if (j != i) {
                    Clase c2 = (Clase) classes.get(j);
                    if (existsGeneralization(c1.name, c2.name)) {
                        for (int k = 0 ; k < relations.size() & allowed ; k++) {
                            Object o = relations.get(k);

                            // It is not necessary to check instantiation because it given by 5)
                            // in validInst.
                            
                            // It is not necessary to check generalization because it given by 3)
                            // in validGen and by existgenLoop.

                            if (o instanceof Association) {
                                Association asso = (Association) o;
                                if (existsAssociation(c1.name, c2.name, asso)) { 
                                    for (int l = 0 ; l < asso.ends.size() & allowed; l++) {
                                        End end = (End) asso.ends.get(l);
                                        if (end.end_class.equals(c2) & end.kind.equals("composite")) 
                                            allowed = false;
                                    }
                                }
                            }
                        }

                        for (int k = 0 ; k < c2.attributes.size() & allowed ; k++) {
                            Attribute at = (Attribute) c2.attributes.get(k);
                            if (getClase(at.type) == c1) 
                                allowed = false;
                        }

                        if (!allowed)
                            System.out.println("Error: When two classes are directly or" + 
                                               " transitively related by a generalization ("+
                                               c1.name + " and " + c2.name + 
                                               "), the superclass can not be the owner of" + 
                                               " the subclass.");
                    }
                }
            }
        }

        return allowed;
    }


    public boolean duplicatedInstantiations() {

	boolean dup = false;

	for (int i = 0; i < relations.size() ; i++) {
	    Object o = relations.get(i);
	    if (o instanceof Instantiation) {
		Instantiation ins1 = (Instantiation) o;
		for (int j = i+1; j < relations.size() ; j++) {
		    o = relations.get(j);
		    if (o instanceof Instantiation) {
			Instantiation ins2 = (Instantiation) o;
			if (ins1.instantiated.equals(ins2.instantiated)){
			    dup = true;
			    System.out.println("Error: Class \"" + ins1.instantiated.name + 
					       "\" instantiated more than once.");
			}
		    }
		}
	    }
	}

	return dup;
    }
       
         
    public boolean validInst(Instantiation ins, int insPos) {

        // It checks that an instantiatiation relationships is valid:
        
        // 1) The instantiated class is fully specified by its template;
        // 2) The number of actual parameters is equal to the number of formal parameters.
        // 3) A template class cannot be target of an association.
	// 4) A template class cannot be a superclass.
        // 5) An instantiated class may only be a target in an association end.
	// 6) An instantiated class cannot be a subclass.
        // 7) Between the template and the instantiated class it does not exist other relation.
        // 8) A template must have at least one formal parameter.
	
        boolean valid = true;

        //1
        if (!fullySpec(ins.instantiated, ins.template))
            valid = false;
        
        //2
        if (ins.template.parameters.size() != ins.actualParameters.size()) {
            System.out.println("Error: Different number of actual and formal parameters" +
                               " in instantiation between \"" + ins.instantiated.name +
                               "\" and \"" + ins.template.name + "\".");
            valid = false;
        }

        //3
        if (isAssoTarget(ins.template.name)){
            System.out.println("Error: Template class \"" + ins.template.name +
            "\" is target of association. Template classes cannot be target of associations.");
            valid = false;
        }

	//4
	if (isaSuperclass(ins.template)) {
	    System.out.println("Error: Class " + ins.template.name +
            " is a superclass. Template classes cannot be superclasses");
            valid = false;
        }

        //5
        if (isAssoSource(ins.instantiated.name)) {
             System.out.println("Error: Instantiated class " + ins.instantiated.name + 
             " is source of association. Instantiated classes only can be target of associations.");
            valid = false;
        }

        //6
	if (getGenWhereIsSubclass(ins.instantiated) != null) {
	    System.out.println("Error: Instantiated class \"" + ins.instantiated.name + 
             "\" is a subclass. Instantiated classes cannot be subclasses.");
            valid = false;
        }

        //7
        if (existsRelation(ins.instantiated, ins.template, insPos))
            valid = false;

        //8
        if (ins.template.parameters.size() == 0) {
            System.out.println("Error: Invalid instantiation relationship between \"" + 
                               ins.instantiated.name + "\" and \"" + ins.template.name + "\". Class \""  + 
                               ins.template.name + "\" is not really a template " +
                               "class. It must have at least one formal parameter.");
            valid = false;
        }
		
        return valid;

    }
                
    public boolean isAssoTarget(String classname) {
        
        // Auxiliary method invoked by validInst(_). 
        // It checks if a template class is target of an association.

        boolean is = false;
        Association asso;
        Object o;

        for (int i = 0 ; i < relations.size() & !is ; i++) {
            o = relations.get(i);
            if (o instanceof Association) {
                asso = (Association) o;
                is = asso.isaTarget(classname);
            }
        }

        return is;
    }


    public boolean isAssoSource(String classname) {
        
        // Auxiliary method invoked by validInst(_). 
        // It checks if a template class is source of an association.

        boolean is = false;
        Association asso;
        Object o;

        for (int i = 0 ; i < relations.size() & !is ; i++) {
            o = relations.get(i);
            if (o instanceof Association) {
                asso = (Association) o;
                is = asso.isaSource(classname);
            }
        }

        return is;
    }

    
    public boolean existsRelation(Clase cl1, Clase cl2, int relPos) {

        boolean exist = false;
        Object o;
        Association asso;
        Instantiation ins;
        Generalization gen;
        Dependency dep;

        for (int i = 0 ; i < relations.size(); i++) {
            if (i != relPos) {
                o = relations.get(i);
                if (o instanceof Association) {
                    asso = (Association) o;
                    if (existsAssociation(cl1.name, cl2.name, asso)) {
                        exist = true;
                        System.out.println("Error: Not allowed association (" + asso.name + ") between \"" +
                                       cl1.name + "\" and \"" + cl2.name + 
                                           "\". No other relation is possible between a template and an " +
                                           "instantiated class.");
                    }
                }
                else {
                    if (o instanceof Instantiation) {
                        ins = (Instantiation) o;
                        if (existsInstantiation(cl1.name, cl2.name, ins) | 
                            existsInstantiation(cl2.name, cl1.name, ins)) {
                            exist = true;
                            System.out.println("Error: Not allowed instantiation between \"" + cl1.name + 
                                               "\" and \"" +cl2.name + 
					       "\". No other relation is possible between"+ 
                                               " a template and an instantiated class.");
                        }
                    }
                }
            }
        }

        for (int i = 0 ; i < cl1.attributes.size() & !exist ; i++) {
            Attribute at = (Attribute) cl1.attributes.get(i);
            if (getClase(at.type) == cl2) {
                exist = true;
                System.out.println("Error: Not allowed composition between \"" + cl1.name + 
                                   "\" and \"" +cl2.name +"\". No other relation is possible between"+ 
                                   " a template and an instantiated class.");
            }
        }

        for (int i = 0 ; i < cl2.attributes.size() & !exist ; i++) {
            Attribute at = (Attribute) cl2.attributes.get(i);
            if (getClase(at.type) == cl1) {
                exist = true;
                System.out.println("Error: Not allowed composition between \"" + cl2.name + 
                                   "\" and \"" +cl1.name +"\". No other relation is possible between"+ 
                                   " a template and an instantiated class.");
            }
        }

        //if (existsGeneralization(cl1, cl2) | existsGeneralization(cl2, cl1) ) {
        //  System.out.println("Error: Not allowed direct or transitive generalizations between " + cl1 + 
        //                             " and " + cl2 + ". No other relation is possible between" + 
        //                             " a template and an instantiated class.");
        //  exist = true;
        //}

        
        return exist;
        
    }
        

    public boolean commonEndClass(Vector<End> ends1, Vector<End> ends2) {

        // Auxiliary method used by method duplicatedAssocName(_,_).
        
        boolean common = false;
        End e1, e2;

        for (int i = 0 ; i < ends1.size() & !common ; i++) {
            e1 = (End) ends1.get(i);
            for (int j = 0 ; j < ends2.size() & !common ; j++) {
                e2 = (End) ends2.get(j);
                if (e1.end_class.name.equals(e2.end_class.name))
                    common = true;
            }
        }

        return common;
    }
        

    public boolean fullySpec(Clase instantiated, Clase template) {

        // Auxiliary method invoked by validInst(_). 
        // It checks if an instantiated class is fully specified by its template.

        boolean valid = true;

        if (instantiated.attributes.size() != 0) {
            System.out.println("Error: in instantiated class \"" + instantiated.name + 
            "\". Instantiated classes are fully specifyed by its template. It cannot add new attributes.");
            valid = false;
        }
        if (instantiated.operations.size() != 0) {
            System.out.println("Error: in instantiated class \"" + instantiated.name + 
            "\". Instantiated classes are fully specifyed by its template. It cannot add new operations.");
            valid = false;
        }
        if (!template.multiplicity.lower.equals(instantiated.multiplicity.lower) |
            !template.multiplicity.upper.equals (instantiated.multiplicity.upper) ){
            System.out.println("Error: in instantiated class \"" + instantiated.name + 
                               "\". Instantiated classes are fully specifyed by its template. " + 
                               "It must have the same multiplicity");
            valid = false;
        }
        if (template.is_abstract != instantiated.is_abstract) {
            System.out.println("Error: in instantiated class \"" + instantiated.name + 
                               "\". Instantiated classes are fully specifyed by its template. " + 
                               "Both must be abstract or both must be concrete.");
            valid = false;
        }
        if (template.is_root != instantiated.is_root |
            template.is_leaf != instantiated.is_leaf) {
            System.out.println("Error: in instantiated class \"" + instantiated.name + 
                               "\". Instantiated classes are fully specifyed by its template. " + 
                               "Both must have the same properties (root, leaf,etc.).");
            valid = false;
        }
        
        return valid;
    }


    public boolean existsAssociation(String cl1, String cl2, Association asso) {

        return asso.isinEnds(cl1) & asso.isinEnds(cl2);

    }


    public boolean existsDependency(String cl1, String cl2, Dependency dep) {

         return dep.source.name.equals(cl1) & dep.target.name.equals(cl2);
    }


    public boolean existsGeneralization(String subclass, String superclass) {

	/* Inform if exists direct or transitive inheritance between subclass and superclass */ 
 
	boolean exist = false;
        Vector<Pair> gens = union(getGeneralizations(), getInstantiations());
        closure(gens);
	for (int i = 0; i < gens.size() & !exist; i++) {
            Pair p = (Pair) gens.get(i);
            if (p.c1.equals(subclass) & p.c2.equals(superclass))
                exist = true;
        }

        return exist;
            
    }

    public boolean existsInstantiation(String cl1, String cl2, Instantiation ins) {
        
        return ins.template.name.equals(cl1) & ins.instantiated.name.equals(cl2);
    }


    public boolean validGen(Generalization gen, int genPos) {

        // It checks that a generalization is valid: 

        // 1) a subclass cannot be a root class;
        // 2) a superclass cannot be a leaf class;
        // 3) multiple inheritance not allowed.
	
        boolean valid = true;

        //1
        if (gen.subclass.is_root){
            valid = false;
            System.out.println("Error: Subclass \"" + gen.subclass.name +
                             "\" labeled as root. A subclass cannot be root.");
        }
        //2
        if (gen.superclass.is_leaf) {
            valid = false;
            System.out.println("Error: Superclass \"" + gen.superclass.name + 
                               "\" labeled as leaf. A superclass cannot be leaf.");
        }

        //3
        if (existsMultipleInheritance(gen, genPos)) {
            valid = false;
            System.out.println("Error: Class \"" + gen.subclass.name +
			       "\" inherits from more than one class. Multiple inheritance not allowed.");

	}

	//4
	if (gen.redefineAtts()) {
	    valid = false;
            System.out.println("Error: Class \"" + gen.subclass.name+ "\" redefines superclass attributes.");
	}

        return valid;
    }

    public boolean existsMultipleInheritance(Generalization gen, int genPos){
        
        boolean exist = false;
        Object o;
        Generalization gen1;

        for (int i = genPos + 1 ; i < relations.size() & !exist ; i++) {
            o = relations.get(i);
            if (o instanceof Generalization) {
                gen1 = (Generalization) o;
                if (gen1.subclass.equals(gen.subclass)) 
                    exist = true;
            }
        }

        return exist;

    }


    public void closure(Vector<Pair> v) {

//  	System.out.print("G={");
//  	for (int i = 0 ; i < v.size() ; i++) {
//  	    Pair p = (Pair) v.get(i);
//  	    System.out.print( "("+ p.c1 + "," + p.c2  + ")"); 
//  	} 
//      System.out.println("}");
	        

	for (int i = 0 ; i < v.size(); i++){
	   Pair p1 = (Pair) v.get(i);
	   for (int j = 0 ; j < v.size() ; j++) {
                 Pair p2 = (Pair) v.get(j);
                 if (p1.c2.equals(p2.c1)) {
		     Pair newp = new Pair(p1.c1, p2.c2);
		     if (!isInRel(v, newp))
			 v.addElement(newp);
		 }
	   }
        }

//	System.out.print("trans(G)={");
//      for (int i = 0 ; i <v.size() ; i++) {
//  	    Pair p = (Pair) v.get(i);
//  	    System.out.print( "("+p.c1 + ","+ p.c2  +")"); 
//      }
//      System.out.println("}");
    
    }


    public boolean isInRel(Vector<Pair> v, Pair p) {
	
	boolean isin = false;

	for (int i = 0 ; i < v.size() & ! isin; i++){
	    Pair p1 = (Pair) v.get(i);
	    if (p.c1.equals(p1.c1) & p.c2.equals(p1.c2))
		isin = true;
	}

	return isin;
    }		


    public boolean equalRels(Vector<Pair> r1, Vector<Pair> r2) {

        return isContained(r1, r2) & isContained(r2, r1);
    }
    

    public boolean isContained(Vector<Pair> r1, Vector<Pair> r2) {

        boolean is = true;

        for (int i = 0 ; i < r1.size()  & is ; i++) {
            Pair p1 = (Pair) r1.get(i);
            is = false;
            for (int j = 0 ; j < r2.size() & !is ; j++) {
                 Pair p2 = (Pair) r2.get(j);
                 if (p1.c1.equals(p2.c1) & p1.c2.equals(p2.c2))
                     is = true;
            }
        }
        
        return is;

    }


    public Vector<Pair> union(Vector<Pair> v1, Vector<Pair> v2) {

         for (int i = 0; i < v2.size(); i++) {
             Pair p = (Pair) v2.get(i);
             if (isInRel(v1, p))
                 v1.addElement(p);
         }

         return v1;
    }

 
    /*  ===================================================================== */                     
    /*        Methods used for generating RSL code from a class diagram       */
    /*  ===================================================================== */    

    public void code(String rslDir) {
       
        Vector<String> types = new Vector<String>(10,1);
        Vector<Clase> topLevelCls;
        Vector<RecAlias> aliases = new Vector<RecAlias>(10, 1);
	File rslDirectory = new File(rslDir);

        if (resolveDirectory(rslDirectory)) {
	    resolveNames(aliases);

	    //  for (int i = 0; i< aliases.size(); i++) {
	    //          RecAlias ra = (RecAlias) aliases.get(i);
	    //  	System.out.println(ra.name + ", " + ra.alias + "," + ra.getKind());
	    //  }

	    topLevelCls = classesCode(rslDirectory, types, aliases);

	    if (types.size() != 0)
		moduleTYPESCode(rslDirectory, types);
	    
	    if (topLevelCls.size() != 0)
		topLevelModuleCode(rslDirectory, topLevelCls, types, aliases);
	    System.out.println("RSL code succesfully generated.");
        }
    } 

    private boolean resolveDirectory(File rslDirectory) {
    
	byte option[]= new byte[1];
	boolean created = false;
	 
       	if (!rslDirectory.isDirectory()) {
	    System.out.println("Error in output file: nonexistent RSL output directory " + rslDirectory.getName() + 
			       " (Absolute Path: " + rslDirectory.getAbsolutePath());
	    System.out.print("Do you want to create it (y/n)? ");
	    try{
		System.in.read(option);
		if (option[0] == 'y') {
		    created =  rslDirectory.mkdir(); 
		    if (!created) 
			System.out.println("Error in output file: Impossible to create directory.");
		}
		else {
		    System.out.println("Error in output file: Impossible to generate RSL code. Missing RSL directory.");
		    created = false;
		}
	    }
	    catch (IOException e) {
		System.out.print("I'm Sorry.  I didn't catch your option.");
	    }
	} 
	else 
	    created = true;
	
	return created;
    }
    

    private Vector<Clase> classesCode(File rslDirectory, Vector<String> types, Vector<RecAlias> aliases) {

        Clase cl;
        Vector<Clase> topLevelCls = new Vector<Clase>(10, 1);

        for (int i = 0 ; i < classes.size() ; i++) {
            cl = (Clase) classes.get(i);
            classCode(rslDirectory, cl, types, aliases);
            if (!cl.isTemplate())   
                topLevelCls.addElement(cl);
        }

        return topLevelCls;
    }


    private void classCode(File rslDirectory, Clase cl, Vector<String> types, Vector<RecAlias> aliases) {

        Instantiation ins = getInsWhereIsInstantiated(cl);

        if (ins == null)
            templatesA2_B_C_E1Code(rslDirectory, cl, types, aliases);
        else
            templatesE2Code(rslDirectory, ins, types, aliases);
        if (!cl.isTemplate()) 
          templateA1Code(rslDirectory, cl, types, aliases);
    }
 
    
    private void templatesA2_B_C_E1Code(File rslDirectory, Clase cl, Vector<String> types, Vector<RecAlias> aliases) {

        //Generates code for templates A2, B, C y E1 and their combinations.
	
	File outputFile; 

	if (cl.isTemplate())
	    outputFile = new File(rslDirectory, getAlias(cl.name + "__", MODULENAME, aliases) + ".rsl");
	else {
	    //System.out.println(cl.name + " "+ getAlias(cl.name + "_", MODULENAME, aliases) + ".rsl");
	    outputFile = new File(rslDirectory, getAlias(cl.name + "_", MODULENAME, aliases) + ".rsl");
	}
	try {
	    FileWriter out = new FileWriter(outputFile);
	    includesCode(cl, out, types, aliases);
	    classExpressionCode(cl, out, types, aliases);
	    out.close();
	}
	catch (IOException e) {
	    System.out.println("Error in output file " + outputFile.getName());
	}
         
    }
 
 
    private void includesCode(Clase cl, FileWriter out, Vector<String> types, Vector<RecAlias> aliases) {
        
        try {
            Generalization gen = getGenWhereIsSubclass(cl);
            
            if (gen == null) 
		out.write("TYPES");
            else
                out.write(getAlias(gen.superclass.name + "_", MODULENAME, aliases));
            out.write("\n\n");
            if (cl.isTemplate())
                out.write("scheme " + getAlias(cl.name + "__", MODULENAME, aliases));
            else
                out.write("object " + getAlias(cl.name + "_", MODULENAME, aliases));
            if (cl.isTemplate()) {            
                classformalParCode(cl, out, types);
                out.write(" =\n");
            }
            else
                out.write(" :\n");
            
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void classExpressionCode(Clase cl, FileWriter out, Vector<String> types, Vector<RecAlias> aliases) {

        try {
	    out.write("   with TYPES in\n");
	    if (cl.is_abstract)
		hideAbstractMethodsCode(cl, "instance", out); 
            out.write("   class\n");
            typesCode(cl, out, types, aliases);
            valuesCode(cl, out, types, aliases);
            out.write("\n   end"); 
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void hideAbstractMethodsCode(Clase cl, String scope, FileWriter out) {

	boolean at_least_one = false;

	try {
	    for (int i = 0; i < cl.operations.size() ; i++) {
		Operation op = (Operation) cl.operations.get(i);
		if (op.is_abstract & op.scope.equals(scope)){
		    if (at_least_one)
			out.write(", ");
		    else {
			out.write("   hide ");
			at_least_one = true;
		    }
		    out.write(op.alias);
		}
	    }
	    if (at_least_one)
		out.write(" in\n");
	}
	catch (IOException e) {
	    System.out.println("Error in output file");
	}
    }


    private void classformalParCode(Clase cl, FileWriter out, Vector<String> types) {
        
        boolean at_least_one;
        int j;
        FormalParameter fp;

        try {
            out.write(" (\n");
            out.write("   FPAR :with TYPES in\n");
	    out.write("     class\n");
            at_least_one = false;
            for (j = 0 ; j < cl.parameters.size() ; j++) {
                fp = (FormalParameter) cl.parameters.get(j);
                if (fp.type.equals("")) {
                    if (at_least_one) 
                        out.write(",\n");
                    else {
                        out.write("        type\n");
                        at_least_one = true;
                    }
                    out.write("          " + fp.name);
                }
            }
            out.write("\n");
            at_least_one = false;
            for (j = 0 ; j < cl.parameters.size() ; j++) {
                fp = (FormalParameter) cl.parameters.get(j);
                if (!fp.type.equals("")) {
                    if (at_least_one) 
                        out.write(",\n");
                    else {
                        out.write("        value\n");
                        at_least_one = true;
                    }
                    out.write("          " + fp.name + ": ");
                    typeCode(cl, fp.type, 1, out, types);
                }
            }
            out.write("\n");
            out.write("     end)");
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
    }


    private void typeCode(Clase cl, String type, int mult_type, FileWriter out, Vector<String> types) {

	
        try {
            switch (mult_type) {
            case 0 :// multiplicity 0..1
                out.write("Optional_" + type); 
                if (cl.isInParNames(type) == -1 & !types.contains("Optional_" + type)){
                    types.addElement("Optional_" + type);
		    if (!types.contains(type))
			types.addElement(type);
		}
                break;
            case 1: // multiplicity 1..1
                if (cl.isInParNames(type) != -1) 
                    out.write("FPAR." + type);
                else {
                    if (getClase(type) != null) {
                        out.write(type + "_Id");
                        if (!types.contains(type + "_Id"))
                            types.addElement(type + "_Id");
                    }
                    else { 
                        if (!UML2RSL.isaRSLtype(type)){
                            out.write(type);
                            if (!types.contains(type))
                                types.addElement(type);
                        }
                        else 
                            out.write(type); 
                    }
                }
                break;
            case 2: // multiplicity > 1
                if (cl.isInParNames(type) != -1) 
                    out.write(type + "s");
                else {
                    if (getClase(type) != null) {
                        out.write(type + "_Id");
                        if (!types.contains(type + "_Id"))
                            types.addElement(type + "_Id");
                    }
                    else {
                        if (!UML2RSL.isaRSLtype(type)){
                            out.write(type);
                            if (!types.contains(type))
                                types.addElement(type);
                        }
                        else 
                            out.write(type); 
                    }
                    out.write("-set");
                }
                break;
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
    }


    private void typesCode(Clase cl, FileWriter out, Vector<String> types, Vector<RecAlias> aliases){
        
        try {
            Generalization gen = getGenWhereIsSubclass(cl);
            
            out.write("     type\n"); 
            if (gen != null)
                subSortCode(cl, gen, out, aliases);
            else {
                if (cl.isLeaf()) 
                    recordCode(cl, out, types, aliases);
                else
                    out.write("          " + cl.name);
            }
            if (cl.isTemplate()) {
                formalParTypesCode(cl, out);
            }
            out.write("\n");
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }



    private void subSortCode(Clase cl, Generalization gen, FileWriter out, Vector<RecAlias> aliases) {

        try {
            out.write("          " + gen.superclass.name + " = " + 
                      getAlias(gen.superclass.name + "_", MODULENAME, aliases) + "." + 
		      gen.superclass.name + ",\n");
            out.write("          " + cl.name + " = {|o: " + gen.superclass.name + " :- ");
            if (startWithVowel(cl.name))
                out.write("is_an_");
            else 
                out.write("is_a_");
            out.write(cl.name + "(o)|}");
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }

    
    private void recordCode(Clase cl, FileWriter out, Vector<String> types, Vector<RecAlias> aliases) {
        
        try {
	    out.write("         " + cl.name); 
	    boolean at_least_one = attributesInRecordCode(cl, out, types);
	    navigablesInRecordCode(cl, out, types, at_least_one);
	}
	catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private boolean attributesInRecordCode(Clase cl, FileWriter out, Vector<String> types) {

        boolean at_least_one = false;

        try {
            for (int i = 0 ; i < cl.attributes.size() ; i++) {
                Attribute at = (Attribute) cl.attributes.get(i);
                if (at_least_one) 
                    out.write("\n");
                else 
                    out.write("::\n");
                out.write("            " + at.alias + ": ");
                if (at.type.equals(""))
                    typeCode(cl, at.alias, at.multiplicity.getMult_type(), out, types);
                else
                    typeCode(cl, at.type, at.multiplicity.getMult_type(), out, types);
                if (at.changeability != FROZEN)  // The attribute is not frozen
                    out.write(" <-> replace_" + at.alias);
                at_least_one = true;
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }

        return at_least_one;
    }


    private void navigablesInRecordCode(Clase cl, FileWriter out, Vector<String> types, boolean at_least_one) {

        try {
            Vector<End> navigables = getNavigables(cl);

            for (int i = 0 ; i < navigables.size() ; i++) {
                End end = (End) navigables.get(i);
                if (at_least_one)
                    out.write("\n");
                else 
                    out.write("::\n");
                out.write("            " + end.alias + ": ");
                typeCode(cl, end.end_class.name, end.multiplicity.getMult_type(), out, types);
                if (end.changeability != FROZEN)  // The association end is not frozen
                    out.write(" <-> replace_" + end.alias);
                at_least_one = true;
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }

    }


    private void formalParTypesCode(Clase cl, FileWriter out) {
	
        try {   
            for (int i = 0 ; i < cl.attributes.size(); i++) {
                Attribute at = (Attribute) cl.attributes.get(i);
                if (cl.isInParNames(at.type) != -1) {
                    switch (at.multiplicity.getMult_type()) {
                    case 0 :
                        out.write(",\n\n          Optional_" + at.type + " == no_" + at.type);
                        if (startWithVowel(at.type))
                            out.write(" | an_");
                        else
                            out.write(" | a_");
                        out.write(at.type + "(id: FPAR." + at.type + ")\n"); 
                        break;
                    case 1:
                        break;
                    case 2:
                        out.write(",\n\n          " + at.type + "s = FPAR." + at.type + "-set\n");
                        break;
                    }
                }
            }
        }           
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void valuesCode(Clase cl, FileWriter out, Vector<String> types, Vector<RecAlias> aliases){
        
        try {
            boolean at_least_one = false;
            Generalization gen = getGenWhereIsSubclass(cl);
           
            if (gen != null | !cl.isLeaf()) 
                at_least_one = attributesValuesCode(cl, out, types, at_least_one);
            at_least_one = update_attributesValuesCode(cl, out, types, at_least_one);
            
            if (gen != null | !cl.isLeaf()) 
                at_least_one = navigablesValuesCode(cl, out, types, at_least_one);
            at_least_one = update_navigablesValuesCode(cl, out, types, at_least_one);
   
            at_least_one = operationsValuesCode(cl, out, types, "instance", at_least_one);
    
            if (gen != null) {
                if (at_least_one)
                    out.write(",\n\n");
                else 
                    out.write("     value\n");
                out.write("          "); 
                if (startWithVowel(cl.name))
                    out.write("is_an_");
                else 
                    out.write("is_a_");
                out.write(cl.name + ": " + gen.superclass.name + " -> " + "Bool");      
                at_least_one = true;
            }
            consistentA2_B_C_E1Code(cl, out, types, aliases, at_least_one);
            
        }
    
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private boolean attributesValuesCode(Clase cl, FileWriter out, Vector<String> types, boolean at_least_one) {
        
        try {
            for (int i = 0 ; i < cl.attributes.size() ; i++) {
                Attribute at = (Attribute) cl.attributes.get(i);
                if (at_least_one)
                    out.write(",\n\n");
                else{
                    out.write("     value\n");
                    at_least_one = true;
                }
                out.write("          " + at.alias + ": " + cl.name + " -> ");
                if (at.type.equals(""))                 
                    typeCode(cl, at.alias, at.multiplicity.getMult_type(), out, types);
                else
                    typeCode(cl, at.type, at.multiplicity.getMult_type(), out, types);
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }

        return at_least_one;
    }

    private boolean update_attributesValuesCode(Clase cl, FileWriter out, Vector<String> types,
                                                boolean at_least_one) {
        
        try {
            Generalization gen = getGenWhereIsSubclass(cl);

            for (int i = 0 ; i < cl.attributes.size() ; i++) {
                Attribute at = (Attribute) cl.attributes.get(i);
                if (at.changeability != FROZEN) { // It is not a frozen at.
                    if (at_least_one)
                        out.write(",\n\n");
                    else{
                        out.write("     value\n");
                        at_least_one = true;
                    }
                    out.write("          update_" + at.alias + ": ");
                    if (at.type.equals(""))
                        typeCode(cl, at.alias, at.multiplicity.getMult_type(), out, types);
                    else
                        typeCode(cl, at.type, at.multiplicity.getMult_type(), out, types);
                    out.write(" >< " + cl.name + " -~-> " + cl.name + "\n");
                    out.write("          " + "update_" + at.alias + "(at, o) ");
                    if (cl.isLeaf() & gen == null) 
                        out.write(" is replace_" + at.alias + "(at, o)\n");
                    else
                        out.write(" as o' post " + at.alias + "(o') = at\n");
                    out.write("              pre preupdate_" + at.alias + "(at, o),\n\n");
                    out.write("          " + "preupdate_" + at.alias + ": ");
                    if (at.type.equals(""))
                        typeCode(cl, at.alias, at.multiplicity.getMult_type(), out, types);
                    else
                        typeCode(cl, at.type, at.multiplicity.getMult_type(), out, types);
                    out.write(" >< " + cl.name + " -> Bool");
                }
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
        return at_least_one;

    }


    private boolean navigablesValuesCode(Clase cl, FileWriter out, Vector<String> types, boolean at_least_one) {

        try {
            Vector<End> navigables = getNavigables(cl);

            for (int i = 0 ; i < navigables.size() ; i++) {
                End end = (End) navigables.get(i);
                if (at_least_one)
                    out.write(",\n\n");
                else{
                    out.write("     value\n");
                    at_least_one = true;
                }
                out.write("          " + end.alias + ": " + cl.name + " -> ");
                typeCode(cl, end.end_class.name, end.multiplicity.getMult_type(), out, types);
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }

        return at_least_one;
    }


    private boolean update_navigablesValuesCode(Clase cl, FileWriter out, Vector<String> types, 
                                                boolean at_least_one) {

        try {
            Generalization gen = getGenWhereIsSubclass(cl);
            Vector<End> navigables = getNavigables(cl);

            for (int i = 0 ; i < navigables.size() ; i++) {
                End end = (End) navigables.get(i);
                if (end.changeability != FROZEN) {  // The end is not frozen
                    if (at_least_one)
                        out.write(",\n\n");
                    else{
                        out.write("     value\n");
                        at_least_one = true;
                    }
                    out.write("          update_" + end.alias + ": ");
                    typeCode(cl, end.end_class.name, end.multiplicity.getMult_type(), out, types);
                    out.write(" >< " + cl.name + " -~-> " + cl.name + "\n");
                    out.write("          update_" + end.alias + "(a, o) ");
                    if (cl.isLeaf() & gen == null)
                        out.write("is replace_" + end.alias + "(a, o)\n");
                    else
                        out.write("as o' post " + end.alias + "(o') = a\n");
                    out.write("              pre preupdate_" + end.alias + "(a, o),\n\n");
                    out.write("          " + "preupdate_" + end.alias +": ");
                    typeCode(cl, end.end_class.name, end.multiplicity.getMult_type(), out, types);
                    out.write(" >< " + cl.name + " -> Bool");
                }
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }

        return at_least_one;
    }


    private boolean operationsValuesCode(Clase cl, FileWriter out, Vector<String> types, String scope,
                                         boolean at_least_one) {

        try {
            for (int i = 0 ; i < cl.operations.size() ; i++) {
                Operation op = (Operation) cl.operations.get(i);
                if (op.scope.equals(scope)) {
                    if (at_least_one)
                        out.write(",\n\n");
                    else{
                        out.write("     value\n");
                        at_least_one = true;
                    }
                    out.write("          " + op.alias + ": ");
                    operFormalParCode(cl, op, out, types, scope);
                    out.write(" -> ");
		    // why empty string for class type? CWG
                    if (op.result.equals("")|op.result.equals(cl.name)){
                        if (scope.equals( "instance"))
                            out.write(cl.name);
                        else
                            out.write(cl.name + "s");
                    }
                    else
                        typeCode(cl, op.result, 1, out, types);
                }
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
        return at_least_one;
    }


    private void operFormalParCode(Clase cl, Operation op, FileWriter out, Vector<String> types, String scope) {
        
        try {
            for (int i = 0 ; i < op.formalparameters.size() ; i++) {
                FormalParameter fp = (FormalParameter) op.formalparameters.get(i);
                if (fp.type.equals("")) 
                        typeCode(cl, fp.name, 1, out, types);
                else
                    typeCode(cl, fp.type, 1, out, types); 
                out.write(" >< ");
            }
            if (scope.equals("instance"))
                out.write(cl.name);
            else
                out.write(cl.name + "s");
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void consistentA2_B_C_E1Code(Clase cl, FileWriter out, Vector<String> types, Vector<RecAlias> aliases,
                                         boolean at_least_one) {

        try {
            if (at_least_one) 
                out.write(",\n\n");
            else
                out.write("     value\n");
            out.write("        consistent: " + cl.name + " -> Bool\n");
            Generalization gen = getGenWhereIsSubclass(cl);
            if (gen != null){
                at_least_one = true;
                out.write("        consistent(o) is\n");
                out.write("            " + getAlias(gen.superclass.name + "_", MODULENAME, aliases) +
                          ".consistent(o)");
            }
            else
                at_least_one = false;
            at_least_one = attributesMultiplicityCheckingsCode(cl, out, at_least_one);
            at_least_one = endsMultiplicityCheckingsCode(cl, out, at_least_one);
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }    
    }


    private boolean attributesMultiplicityCheckingsCode(Clase cl, FileWriter out, boolean at_least_one) {

        try{
            for (int i = 0 ; i < cl.attributes.size() ; i++) {
                Attribute at = (Attribute) cl.attributes.get(i);
                if (at.multiplicity.upper.equals("*")) {
                    if (!at.multiplicity.lower.equals("*") & !at.multiplicity.lower.equals("0")) {
                        if (at_least_one)
                            out.write(" /\\\n");
                        else {
                            out.write("        consistent(o) is\n");
                            at_least_one = true;
                        }
                        out.write("           card " + at.alias + "(o) >= ");
                        if (!Multiplicity.allDigits(at.multiplicity.lower))
                            out.write("FPAR.");
                        out.write(at.multiplicity.lower);
                    }
                }
                else {
                    if (!at.multiplicity.upper.equals("1")){
                        if (at_least_one)
                            out.write(" /\\\n");
                        else {
                            out.write("        consistent(o) is\n");
                            at_least_one = true;
                        }
                        out.write("           card " + at.alias);
                        if (at.multiplicity.upper.equals(at.multiplicity.lower)) {
			    out.write("(o) = ");
                            if (!Multiplicity.allDigits(at.multiplicity.upper))
                                out.write("FPAR.");
                            out.write(at.multiplicity.upper);
                        }
                        else {
                            out.write("(o)>= ");
                            if (!Multiplicity.allDigits(at.multiplicity.lower))
                                out.write("FPAR.");
                            out.write(at.multiplicity.lower);
                            out.write(" /\\ card " + at.alias + "(o) <= ");
                            if (!Multiplicity.allDigits(at.multiplicity.upper))
                                out.write("FPAR.");
                            out.write(at.multiplicity.upper);
                        }
                    }
                }
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }

        return at_least_one;
        
    }


    private boolean endsMultiplicityCheckingsCode(Clase cl, FileWriter out,  boolean at_least_one) {

        Vector<End> ends = getNavigables(cl);
        
        try{
            for (int i = 0 ; i < ends.size() ; i++) {
                End end = (End) ends.get(i);
                if (end.multiplicity.upper.equals("*")) {
                    if (!end.multiplicity.lower.equals("*") & !end.multiplicity.lower.equals("0")) {
                        if (at_least_one)
                            out.write(" /\\\n");
                        else {
                            out.write("        consistent(o) is\n");
                            at_least_one = true;
                        }
                        out.write("           card " + end.alias + "(o) >= ");
                        if (!Multiplicity.allDigits(end.multiplicity.lower))
                            out.write("FPAR.");
                        out.write(end.multiplicity.lower);
                    }
                }
                else {
                    if (!end.multiplicity.upper.equals("1")){
                        if (at_least_one)
                            out.write(" /\\\n");
                        else {
                            out.write("        consistent(o) is\n");
                            at_least_one = true;
                        }
                        out.write("           card " + end.alias);
                        if (end.multiplicity.upper.equals(end.multiplicity.lower)) {
			    out.write("(o) = "); 
                            if (!Multiplicity.allDigits(end.multiplicity.upper))
                                out.write("FPAR.");
                            out.write(end.multiplicity.upper);
                        }
                        else {
                            out.write("(o)>= ");
                            if (!Multiplicity.allDigits(end.multiplicity.lower))
                                out.write("FPAR.");
                            out.write(end.multiplicity.lower);
                            out.write(" /\\ card " + end.alias + "(o) <= ");
                            if (!Multiplicity.allDigits(end.multiplicity.upper))
                                out.write("FPAR.");
                            out.write(end.multiplicity.upper);
                        }
                    }
                }
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
        return at_least_one;
        
    }

 
    private void templatesE2Code(File rslDirectory, Instantiation ins, Vector<String> types, Vector<RecAlias> aliases) {

        //Generates code for templates E2 (instantiation). 

        
        File outputFile = new File(rslDirectory, getAlias(ins.instantiated.name + "__", MODULENAME, aliases) + ".rsl");
 
        try {
            FileWriter out = new FileWriter(outputFile);

            out.write(getAlias(ins.template.name + "__", MODULENAME, aliases));
            out.write("\n\n");
            out.write("scheme " + getAlias(ins.instantiated.name + "__", MODULENAME, aliases));
	    if (ins.instantiated.isTemplate()) {
                //formal parameters if instantiated is also a template
		classformalParCode(ins.instantiated, out, types);
	    }
	    out.write(" =\n");
	    out.write("   with TYPES in");
	    Generalization gen = getGenWhereIsSubclass(ins.template);
	    if (gen != null) {
		out.write("  use is_");
		if (startWithVowel(ins.instantiated.name))
		    out.write("an_");
		else
		    out.write("a_");
		out.write(ins.instantiated.name + " for is_");
		if (startWithVowel(ins.template.name))
		    out.write("an_");
		else
		    out.write("a_");
		out.write(ins.template.name + " in\n");
	    }
            out.write("  extend\n");
            out.write("    class\n\n");
            out.write("       object\n");
            out.write("         APAR_" + ins.instantiated.name + ":\n");
            out.write("           class\n");
            classActualParCode(ins, out, types);
            out.write("\n           end\n");
            out.write("    end\n");
            out.write("  with extend " + getAlias(ins.template.name + "__", MODULENAME, aliases) +
                      "(APAR_" + ins.instantiated.name + ") with class type ");
            out.write(ins.instantiated.name + "=" + ins.template.name);
	    /*if (ins.instantiated.isTemplate()) {
                //types and values if instantiated is also a template- No es necesario porque una 
		//clase instanciada es completamente especificada por su template
		if (ins.instantiated.is_abstract)
		    hideAbstractMethodsCode(ins.instantiated, "instance", out); 
		out.write("   class\n");
		typesCode(ins.instantiated, out, types, aliases);
		valuesCode(ins.instantiated, out, types, aliases);
	    }*/
	    out.write(" end");
            out.close();

            outputFile = new File(rslDirectory, getAlias(ins.instantiated.name + "_", MODULENAME, aliases) + ".rsl");
            out = new FileWriter(outputFile);
            out.write(getAlias(ins.instantiated.name + "__", MODULENAME, aliases) + "\n");
            out.write("object " + getAlias(ins.instantiated.name + "_", MODULENAME, aliases) + ": " +
                      getAlias(ins.instantiated.name + "__", MODULENAME, aliases));
            out.close();
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void classActualParCode(Instantiation ins, FileWriter out, Vector<String> types) {
        
        try {
            boolean at_least_one = false;

            for (int j = 0 ; j < ins.template.parameters.size() ; j++) {
                FormalParameter fp = (FormalParameter) ins.template.parameters.get(j);
                if (fp.type.equals("")) {
                    if (at_least_one) 
                        out.write(",\n");
                    else {
                        out.write("             type\n");
                        at_least_one = true;
                    }
                    out.write("               " + fp.name + " = ");
                    typeCode(ins.instantiated, (String) ins.actualParameters.get(j), 1, out, types);
                }
            }
            out.write("\n");
            at_least_one = false;
            for (int j = 0 ; j < ins.template.parameters.size(); j++) {
                FormalParameter fp = (FormalParameter) ins.template.parameters.get(j);
                if (!fp.type.equals("")) {
                    if (at_least_one) 
                        out.write(",\n");
                    else {
                        out.write("             value\n");
                        at_least_one = true;
                    }
                    out.write("               " + fp.name + ": ");
                    typeCode(ins.instantiated, fp.type, 1, out, types);
                    out.write(" = ");
		    if (ins.instantiated.isInParNames((String) ins.actualParameters.get(j)) != -1)
			out.write(" FPAR.");
		    out.write((String) ins.actualParameters.get(j));
                }
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
    }


    private void moduleTYPESCode(File rslDirectory, Vector<String> types) {

        // Generates module TYPES in RSL
        
        File outputFile = new File(rslDirectory, "TYPES.rsl");
        String classname, optype;
 
        try {
            FileWriter out = new FileWriter(outputFile);

            out.write("object TYPES :\n");
            out.write("  class\n\n");
            out.write("     type\n");
            for (int i = 0 ; i < types.size() ; i++) {
                if (i !=0) 
                    out.write(",\n");
                String t = (String) types.get(i);
                out.write("       " + t);       
                if (t.startsWith("Optional_")){
                    optype = t.substring(9);
                    out.write(" == no_" + optype + " | ");
                    if (startWithVowel(optype))
                        out.write("an_");
                    else
                        out.write("a_");
                    out.write(optype + "(id:" + optype);
                    if (getClase(optype) != null)
                        out.write("_Id)");
                    else
                        out.write(")");
                }
                else {
                    if (t.endsWith("_Id")){
                        Clase cl = getClase(t.substring(0, t.length()-3));
                        if (cl != null) {
			    Clase container = getContainer(cl);
                            if (!container.equals(cl)) 
                                out.write(" = " + container.name + "_" + "Id");
                        }
                    } 
		    else {
			EquivalentTypesTable ett = new EquivalentTypesTable();
			String et = ett.getEquivalentType(t);  
			if (et != null)            // UML data type equivalent to RSL data type
			    out.write(" = " + et);
		    }
                }
            }
            out.write("\n  end\n\n");
            out.close();
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }          
    }


    private void templateA1Code(File rslDirectory, Clase cl, Vector<String> types, Vector<RecAlias> aliases) {

        //Generates code for template A1 (class container). 
        
        File outputFile = new File(rslDirectory, getAlias(cl.name + "S_", MODULENAME, aliases) + ".rsl");
	Generalization gen;
	Instantiation ins = getInsWhereIsInstantiated(cl);
	
	if (ins != null)
	   gen = getGenWhereIsSubclass(ins.template);
	else
	   gen = getGenWhereIsSubclass(cl); 
	
        try {

            FileWriter out = new FileWriter(outputFile);
            if (gen != null)
		out.write(getAlias(gen.superclass.name + "S_", MODULENAME, aliases) + ",");
	    out.write(getAlias(cl.name + "_", MODULENAME, aliases));
            out.write("\n\n");
            out.write("object " + getAlias(cl.name + "S_", MODULENAME, aliases) + " :\n");
	    out.write("  with TYPES in\n");
	    out.write("  class\n\n");
            out.write("     type\n");
            out.write("       " + cl.name + " = " + getAlias(cl.name + "_", MODULENAME, aliases) + "." +
                      cl.name + ",\n");
	    out.write("       " + cl.name + "s = ");
	    if (gen != null) {
		out.write("{| super:" +  getAlias(gen.superclass.name + "S_", MODULENAME, aliases) +
			  "." + gen.superclass.name + "s:- (all id: " + gen.superclass.name 
			  + "_Id :- id isin super =>");
		out.write(getAlias(cl.name + "_", MODULENAME, aliases) + ".");
		if (startWithVowel(cl.name))
		    out.write("is_an_");
		else
		    out.write("is_a_");
		out.write(cl.name + "(super(id)))|}"); 
	    }
	    else
		out.write(cl.name + "_Id -m-> " + cl.name + "\n\n");
	    out.write("     value\n");
	    boolean at_least_one = false;
 	    if (!cl.is_abstract){ 
		// Generate functions on the class container only if cl is concrete
		out.write("          empty:" + cl.name + "s = [],\n\n");

		out.write("          add: " + cl.name + "_Id >< " + cl.name + " >< " + cl.name + 
			  "s -~-> " + cl.name + "s\n");
		out.write("          add(id, o, c) is c !! [id +> o] \n");
		out.write("            pre ~ is_in(id, c),\n\n");
		
		out.write("          del: " + cl.name + "_Id >< " +  cl.name + "s -~-> " + cl.name + "s\n");
		out.write("          del(id, c) is c \\ {id} \n");
		out.write("            pre is_in(id, c),\n\n");
		
		out.write("          is_in: " + cl.name + "_Id >< " + cl.name + "s -> Bool\n");
		out.write("          is_in(id, c) is id isin c, \n\n");
		
		out.write("          get: " + cl.name + "_Id >< " + cl.name + "s -~-> " + cl.name + "\n");
		out.write("          get(id, c) is c(id)\n");
		out.write("            pre is_in(id, c),\n\n");
		
		out.write("          update: " + cl.name + "_Id >< " + cl.name + " >< " + cl.name +
			  "s -~-> " + cl.name + "s\n");
		out.write("          update(id, o, c) is c !! [id +> o]\n");
		out.write("            pre is_in(id, c)");
		at_least_one = true;
		operationsValuesCode(cl, out, types, "classifier", at_least_one);
	    }
            consistentA1Code(cl, out, aliases, at_least_one);
            
            out.write("\n  end\n\n");
            out.close();

            if (!types.contains(cl.name + "_Id")) 
                types.addElement(cl.name + "_Id");
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void consistentA1Code(Clase cl, FileWriter out, Vector<RecAlias> aliases, boolean at_least_one) {

        try {
	    if (at_least_one)
		out.write(",\n\n");
            out.write("          consistent:" + cl.name + "s -> Bool\n");
            out.write("          consistent(c) is ");
            out.write("(all id: " + cl.name + "_Id :- id isin c => ");
            out.write(getAlias(cl.name + "_", MODULENAME, aliases) + ".consistent(c(id)))");
            classMultiplicityCheckingCode(cl, out, aliases);
            class_scopedAttributesCheckingsCode(cl, out, aliases);           
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void classMultiplicityCheckingCode(Clase cl, FileWriter out, Vector<RecAlias> aliases) {
        
        try{
            if (cl.multiplicity.upper.equals("*")) {
                if (!cl.multiplicity.lower.equals("*") & !cl.multiplicity.lower.equals("0")) 
                    out.write(" /\\\n" + "           card dom c >= " + cl.multiplicity.lower);
            }
            else {
                out.write(" /\\\n" + "           card dom ");
                if (cl.multiplicity.upper.equals(cl.multiplicity.lower))
                    out.write("c = " + cl.multiplicity.lower);
                else 
                    out.write("c >= " + cl.multiplicity.lower +  " /\\ card dom c <= " +
                              cl.multiplicity.upper);
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }  
    }


    private void class_scopedAttributesCheckingsCode(Clase cl, FileWriter out, Vector<RecAlias> aliases) {

	Instantiation ins = getInsWhereIsInstantiated(cl);

        try{
	    Vector<Attribute> ats;
	    String module;
	    
	    if (ins != null) 
                ats = ins.template.attributes;
            else 
                ats = cl.attributes;
	    
            for (int i = 0 ; i < ats.size() ; i++){
                Attribute at = (Attribute) ats.get(i);
                if (at.scope.equals("classifier")) {
                    out.write("/\\ \n");
		    out.write("(all id1: " + cl.name + "_Id :- id1 isin c =>\n");
		    out.write("(all id2: " + cl.name + "_Id :- id2 isin c =>\n");
		    module = getAlias(cl.name + "_", MODULENAME, aliases);
                    out.write(module + "." + at.alias + "(c(id1)) = ");
                    out.write(module + "." + at.alias + "(c(id2))))");
                }
            }
        }        
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void topLevelModuleCode(File rslDirectory, Vector<Clase> topLevelCls, Vector<String> types, Vector<RecAlias> aliases) {

        File outputFile = new File(rslDirectory, "S.rsl");
 
        try {
            FileWriter out = new FileWriter(outputFile);
            
            topLevelIncludesCode(topLevelCls, out, aliases);
            topLevelObjectsCode(topLevelCls, out, aliases);
            topLevelTypeSysCode(topLevelCls, out, aliases);
            topLevelValuesCode(topLevelCls, out, types, aliases);
            topLevelPropertyValuesCode(topLevelCls, out, aliases);
            out.write("\nend");
            out.close();
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void topLevelIncludesCode(Vector<Clase> topLevelCls, FileWriter out, Vector<RecAlias> aliases) {

        try {
            for (int i = 0 ; i < topLevelCls.size() ; i++) {
                Clase cl = (Clase) topLevelCls.get(i);
                if (i !=0)
                    out.write(", ");
                out.write(getAlias(cl.name + "S_", MODULENAME, aliases));
            }
            out.write("\n\n");
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void topLevelObjectsCode(Vector<Clase> topLevelCls, FileWriter out, Vector<RecAlias> aliases) {

        try {
            out.write("object S :\n");
	    out.write("   with TYPES in\n");
            out.write("   class\n");
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void topLevelTypeSysCode(Vector<Clase> topLevelCls, FileWriter out, Vector<RecAlias> aliases) {
        
        try{
            out.write("      type\n");
            out.write("         Sys::\n");
            for (int i = 0 ; i < topLevelCls.size() ; i++) {
                Clase cl = (Clase) topLevelCls.get(i);
                if (getContainer(cl).equals(cl)) {
                    out.write("           " + getAlias(cl.name + "s", RECORDFIELD, aliases) + ": ");
                    out.write(getAlias(cl.name + "S_", MODULENAME, aliases) + "." +
                              cl.name + "s <-> replace_" + getAlias(cl.name + "s", RECORDFIELD, aliases) + "\n");
                }
            }
            out.write("\n");
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
    }


    private Clase getContainer(Clase cl) {

	Clase cont = cl;

	Generalization gen = getGenWhereIsSubclass(cl);
          
	if (gen != null)  // cl es subclase
	    cont = gen.superclass;
	else {
	    Instantiation ins = getInsWhereIsInstantiated(cl);
	    if (ins != null) {// cl es instant
		gen = getGenWhereIsSubclass(ins.template);
		if (gen != null) // the template is a subclass
		    cont = gen.superclass;
	    }
	}
	
	return cont;

    }


    private void topLevelValuesCode(Vector<Clase> topLevelCls, FileWriter out, Vector<String> types, Vector<RecAlias> aliases) {

        boolean at_least_one = false;
        boolean at_least_oneFrozenAtt, at_least_oneAddOnlyAtt, at_least_oneFrozenAsso, 
                at_least_oneAddOnlyAsso;
        
        try{
            out.write("      value\n");
            for (int i = 0 ; i < topLevelCls.size() ; i++) {
                Clase cl = (Clase) topLevelCls.get(i);
		Clase container = getContainer(cl);
                if (!container.equals(cl))  // cl is a subclass.
                    at_least_one = containerValueCode(cl, container, out, at_least_one, aliases);
		if (at_least_one)
                    out.write(",\n\n");
		else 
		    at_least_one = true;
                out.write("        update_" + getAlias(cl.name + "s", RECORDFIELD, aliases) + ": " +
                          getAlias(cl.name + "S_", MODULENAME, aliases) + "." + cl.name + "s >< Sys -~-> Sys\n");
                out.write("        update_" + getAlias(cl.name + "s", RECORDFIELD, aliases) + "(c, s) is ");
                if (container.equals(cl))
                    out.write("replace_" + getAlias(cl.name + "s", RECORDFIELD, aliases));
                else
                    out.write("update_" + getAlias(container.name + "s", RECORDFIELD, aliases));
                out.write("(c,s)\n");
		out.write("        as s' post consistent(s')");
                at_least_oneFrozenAtt = thereArePropertyAttsInPostCode(cl, FROZEN);
                if (at_least_oneFrozenAtt)
                    out.write(" /\\ frozenAtts_in_" + cl.name + "(s', s)");
                at_least_oneAddOnlyAtt = thereArePropertyAttsInPostCode(cl, ADDONLY);
                if (at_least_oneAddOnlyAtt)
                    out.write(" /\\ addOnlyAtts_in_" + cl.name + "(s', s)");
                at_least_oneFrozenAsso = thereArePropertyEndsInPostCode(cl, FROZEN);
                if (at_least_oneFrozenAsso)
                    out.write(" /\\ frozenAssocs_in_" + cl.name + "(s', s)");
                at_least_oneAddOnlyAsso = thereArePropertyEndsInPostCode(cl, ADDONLY);
                if (at_least_oneAddOnlyAsso)
                    out.write(" /\\ addOnlyAssocs_in_" + cl.name + "(s', s)");
		out.write("\n");
                out.write("        pre consistent(s) /\\ preupdate_" + getAlias(cl.name + "s", RECORDFIELD, aliases) + "(c, s),\n\n");
                out.write("        preupdate_" + getAlias(cl.name + "s", RECORDFIELD, aliases) + ": " + 
                          getAlias(cl.name + "S_", MODULENAME, aliases) + "." + cl.name + "s >< Sys -> Bool"); 
		topLevelDelWholeAndPartsValueCode(cl, out, aliases);
		topLevelOpsValueCode(cl, out, types, aliases, true);
	    }
	    
            out.write(",\n\n");
            topLevelConsistentCode(topLevelCls, out, aliases);
            out.write("\n\n");
        }           
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
    }
    

    private boolean containerValueCode(Clase cl, Clase container, FileWriter out, boolean at_least_one, 
				       Vector<RecAlias> aliases) {

	// This RSL value is generated  when class cl is a subclass. It returns the class container from the 
	// superclass container.

        try{
	    if (at_least_one)
		out.write(",\n\n");
	    else
		at_least_one = true;
            out.write("           " + getAlias(cl.name + "s", RECORDFIELD, aliases) + ": ");
            out.write("Sys -> " + getAlias(cl.name + "S_", MODULENAME, aliases) + "." + cl.name + "s\n");
            out.write("           " + getAlias(cl.name + "s", RECORDFIELD, aliases) + "(s) is\n");
            out.write(getAlias(container.name + "s", RECORDFIELD, aliases) + "(s) /");
            out.write("{id | id: " + cl.name + "_Id" + ":- id isin " +
                      getAlias(container.name + "s", RECORDFIELD, aliases) + "(s) /\\");
            out.write(getAlias(cl.name + "_", MODULENAME, aliases) + ".");
            if (startWithVowel(cl.name)) 
                out.write("is_an_");
            else
                out.write("is_a_");
            out.write(cl.name + "(" + getAlias(container.name + "s", RECORDFIELD, aliases) + "(s)(id))}");
	}           
        catch (IOException e) {
            System.out.println("Error in output file");
        }

	return at_least_one;
	
    }


    private void topLevelDelWholeAndPartsValueCode(Clase cl, FileWriter out, Vector<RecAlias> aliases) {

	// When cl is a whole, it generates the function for delete an object of cl and its parts.

	Vector<End> parts;
	Instantiation ins = getInsWhereIsInstantiated(cl);

	if (ins != null)
	    parts= getParts(ins.template);
	else
	    parts = getParts(cl);

	if (parts.size() != 0) {
	    try{
		String wContainer = getAlias(cl.name + "s", RECORDFIELD, aliases);
		String pathToWhole = getAlias(cl.name + "_", MODULENAME, aliases);
		out.write(",\n");
		out.write("del_" + cl.name + ": " + cl.name + "_Id >< Sys -~-> Sys\n");
		out.write("del_" + cl.name + "(id, s) as s'' post \n");
		for (int i = 0; i < parts.size() ; i++) {
		    End end = (End) parts.get(i);
		    String pContainer = getAlias(end.end_class.name + "s", RECORDFIELD, aliases);
		    if (i != 0)
			out.write(" /\\ \n");
		    out.write("(exists s': Sys, new_whole: " + getAlias(cl.name + "S_", MODULENAME, aliases) 
			      + "." + cl.name + "s,\n");
		    out.write("new_parts: " + getAlias(end.end_class.name + "S_", MODULENAME, aliases)
			      +"." + end.end_class.name + "s,\n");
		    out.write("parts: " + end.end_class.name + "_Id-set :-");
		    out.write("parts = ");
		    if (end.multiplicity.getMult_type() == 0){ // "0..1"
			out.write("case " + pathToWhole + "." + end.alias + "(" + wContainer +
				  "(s)(id)) of\n");
			if (startWithVowel(end.end_class.name))
			    out.write("an_");
			else
			    out.write("a_");
			out.write(end.end_class.name + "(id) -> {id},\n");
			out.write("no_" + end.end_class.name + " -> {} end /\\\n");
		    }
		    else {
			if (end.multiplicity.getMult_type() == 1) // "1..1"
			    out.write("{" + pathToWhole + "." + end.alias + "(" + wContainer +
				      "(s)(id))} /\\\n");
			else
			    out.write(pathToWhole + "." + end.alias + "(" + wContainer + "(s)(id)) /\\ ");
		    }
		    out.write("new_parts = " + pContainer + "(s) \\ parts /\\");
		    out.write("s' = update_" + getAlias(end.end_class.name + "s", RECORDFIELD, aliases) +
			      "(new_parts, s) /\\");
		    out.write("new_whole = " + getAlias(cl.name + "S_", MODULENAME, aliases) + 
			      ".del(id," + wContainer + "(s')) /\\ ");
		    out.write("s'' = update_" + getAlias(cl.name + "s", RECORDFIELD, aliases) + "(new_whole, s)) \n ");
		}
		out.write("pre can_del_" + cl.name + "(id, s),\n\n");

		out.write("can_del_" + cl.name + ": " + cl.name + "_Id >< Sys -> Bool\n");
		out.write("can_del_" + cl.name + "(id, s) is \n");
		out.write(getAlias(cl.name + "S_", MODULENAME, aliases) + ".is_in(id, " + wContainer + "(s)) /\\");
		for (int i = 0; i < parts.size() ; i++) {
		    End end = (End) parts.get(i);
		    String pContainer = getAlias(end.end_class.name + "s", RECORDFIELD, aliases);
		    if (i != 0)
			out.write(" /\\ \n");
		    
		    out.write("(exists s': Sys, new_whole: " + getAlias(cl.name + "S_", MODULENAME, aliases) + "." 
			      + cl.name + "s,\n");
		    out.write("new_parts: " + getAlias(end.end_class.name + "S_", MODULENAME, aliases)
			      + "." + end.end_class.name + "s,\n");
		    out.write("parts: " + end.end_class.name + "_Id-set :-");
		    out.write("parts = ");
		    if (end.multiplicity.getMult_type() == 0){ // "0..1"
			out.write("case " + pathToWhole + "." + end.alias + "(" + wContainer +
				  "(s)(id)) of\n");
			if (startWithVowel(end.end_class.name))
			    out.write("an_");
			else
			    out.write("a_");
			out.write(end.end_class.name + "(id) -> {id},\n");
			out.write("no_" + end.end_class.name + " -> {} end /\\");
		    }
		    else {
			if (end.multiplicity.getMult_type() == 1) // "1..1"
			    out.write("{" + pathToWhole + "." + end.alias + "(" + wContainer +
				      "(s)(id))} /\\");
			else
			    out.write(pathToWhole + "." + end.alias + "(" + wContainer + "(s)(id)) /\\");

		    }
		    out.write("new_parts = " + pContainer + "(s) \\ parts /\\");
		    out.write("preupdate_" + pContainer + "(new_parts, s) /\\");
		    out.write("s' = update_" + pContainer + "(new_parts, s) /\\");
		    out.write("new_whole = " + getAlias(cl.name + "S_", MODULENAME, aliases) + 
			      ".del(id," + wContainer + "(s'))/\\ ");
		    out.write("preupdate_" + getAlias(cl.name + "s", RECORDFIELD, aliases) + "(new_whole, s)) \n ");
		}
	    }
	    catch (IOException e) {
		System.out.println("Error in output file");
	    }
	}
    }


    private boolean topLevelOpsValueCode(Clase clase, FileWriter out, Vector<String> types, Vector<RecAlias> aliases, 
					 boolean at_least_one) {

	Clase cl;
	Instantiation ins = getInsWhereIsInstantiated(clase);
	
	if (ins != null) 
	    cl = ins.template;
	else
	    cl = clase;

	try {
            for (int i = 0 ; i < cl.operations.size() ; i++) {
                Operation op = (Operation) cl.operations.get(i);
                if (!op.is_abstract) {
                    if (at_least_one)
                        out.write(",\n\n");
                    else{
                        out.write("     value\n");
                        at_least_one = true;
                    }
                    out.write("          " + op.alias + "_in_" + clase.name);
		    if (op.scope.equals("classifier"))
			out.write("s");
		    out.write(": ");
		    topLevelOperFormalParCode(clase, op, out, aliases);
		    out.write(" -> ");
		    topLevelResultTypeCode(clase, op.result, out, aliases);
		}
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
        return at_least_one;

    }


    private void topLevelOperFormalParCode(Clase cl, Operation op, FileWriter out, Vector<RecAlias> aliases) {

	try {
            for (int i = 0 ; i < op.formalparameters.size() ; i++) {
                FormalParameter fp = (FormalParameter) op.formalparameters.get(i);
                if (fp.type.equals("")) 
		    topLevelPFTypeCode(cl, fp.name, out, aliases);
                else
                    topLevelPFTypeCode(cl, fp.type, out, aliases); 
                out.write(" >< ");
            }
            if (op.scope.equals("instance"))
                out.write(getAlias(cl.name + "_", MODULENAME, aliases) + "." + cl.name);
            else
                out.write(getAlias(cl.name + "S_", MODULENAME, aliases) + "." + cl.name + "s");
	    out.write(" >< Sys");
	    
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void topLevelPFTypeCode(Clase cl, String type, FileWriter out, Vector<RecAlias> aliases) {
        		
	int pos = -1;
	Instantiation ins = getInsWhereIsInstantiated(cl);	
	    
	try {
	    if (ins != null) 
		pos= ins.template.isInParNames(type);
	    if (pos != -1){  // type is a formal parameter, it must be instantiated.
		String ap = (String)ins.actualParameters.get(pos); // Get actual parameter
		if (getClase(ap) != null) // Actual parameter is a class
		    out.write(getAlias(ap + "_", MODULENAME, aliases) + "." );
		out.write(ap);
	    }
	    else{
		if (getClase(type) != null) // type is a class
		    out.write(getAlias(type + "_", MODULENAME, aliases) + "." );
		out.write(type);    
	    }
	}
    
	catch (IOException e) {
            System.out.println("Error in output file");
        }
        
    }


    private void topLevelResultTypeCode(Clase cl, String type, FileWriter out, Vector<RecAlias> aliases) {

	int pos = -1;
	Instantiation ins = getInsWhereIsInstantiated(cl);	
	    
	try {
	    if (type.equals(""))
		out.write("Sys");
	    else{
		if (ins != null) 
		    pos = ins.template.isInParNames(type);
		if (pos != -1){ // type is a formal parameter 
		    String ap = (String)ins.actualParameters.get(pos);
		    if (getClase(ap) != null)   // The actual parameter is a class
			out.write("Sys");
		    else 
			out.write(ap);
		}
		else {
		    if (getClase(type) != null) // type is a class
			out.write("Sys");
		    else
			out.write(type);
		}
	    }
	}
	catch (IOException e) {
            System.out.println("Error in output file");
        }	    

    }


    private void topLevelConsistentCode(Vector<Clase> topLevelCls, FileWriter out, Vector<RecAlias> aliases) {

        try{
            out.write("        consistent: Sys -> Bool\n");
            boolean at_least_one = topLevelClsConsistentCode(topLevelCls, out, aliases, false);
            at_least_one = topLevelExistOrBiNavCheckingsCode(out, aliases, at_least_one);
            topLevelAbsClassInvariantsCode(topLevelCls, out, aliases, at_least_one);
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private boolean topLevelClsConsistentCode(Vector<Clase> topLevelCls, FileWriter out, Vector<RecAlias> aliases, boolean at_least_one) {

        try{
            for (int i = 0 ; i < topLevelCls.size() ; i++) {
                Clase cl = (Clase) topLevelCls.get(i);
		if (at_least_one) 
		    out.write(" /\\\n");
		else 
		    out.write("        consistent(s) is \n");
		out.write("           " + getAlias(cl.name + "S_", MODULENAME, aliases) + ".consistent(");
                out.write(getAlias(cl.name + "s", RECORDFIELD, aliases) + "(s))");
                at_least_one = true;
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }

        return at_least_one;
    }

              
        private boolean topLevelExistOrBiNavCheckingsCode(FileWriter out, Vector<RecAlias> aliases, boolean at_least_one) {
        
        //First it checks all the associations and compositions

        for (int i = 0; i < relations.size(); i++) {
            Object o = relations.get(i);
            if (o instanceof Association) {
                Association asso = (Association) o;
                at_least_one = topLevelExistOrBiNavCheckingCode(asso, out, aliases, at_least_one);      
            }
        }

        // Then it checks all the attributes that are represented as compositions.
        
        for (int i = 0; i < classes.size(); i++){
            Clase clase = (Clase)classes.get(i);
            for (int j = 0; j < clase.attributes.size() ; j++) {
                Attribute at = (Attribute) clase.attributes.get(j);
                Clase end_class = getClase(at.type);
                if (end_class != null) { //It is a composition 
                    End whole = new End(clase, at.name, at.alias, new Multiplicity("1","1"), false,
                                        "composite", CHANGEABLE);
                    End part = new End(end_class, at.name, at.alias, at.multiplicity, true, "none",
                                       at.changeability);
                    Vector<End> ends = new Vector<End>(2); 
                    ends.addElement(part);
                    ends.addElement(whole);
                    Association asso = new Association(at.name, at.alias,  ends);
                    at_least_one = topLevelExistOrBiNavCheckingCode(asso, out, aliases, at_least_one);
                }
            }
        }                   
        
        return at_least_one;        
    }
         

    private boolean topLevelExistOrBiNavCheckingCode(Association asso, FileWriter out, Vector<RecAlias> aliases,
                                                 boolean at_least_one) {

        End end1 = (End) asso.ends.get(0);
        End end2 = (End) asso.ends.get(1);
        
        try {
	    if (end2.navigable) {
                if (end1.end_class.isTemplate()) {
		    for (int i = 0 ; i < classes.size() ; i++) {
			Clase cl = (Clase) classes.get(i);
			Instantiation ins = getInsWhereIsInstantiated(cl);
			if (ins != null) {
			    if (ins.template.equals(end1.end_class)) {
				if (at_least_one) 
				    out.write("\n /\\");
				else 
				    out.write("        consistent(s) is \n");
				at_least_one = true; 
				out.write("(");
				forall_idListCode(ins.instantiated, out);
				antecCode(ins.instantiated, end2, out, aliases);
				conseqCode(ins.instantiated, end1, end2, out, aliases);
				out.write(")");
			    }
			}
		    }
		}
		else {
		    if (at_least_one) 
			out.write("\n /\\");
		    else 
			out.write("        consistent(s) is \n");
		    at_least_one = true; 
		    out.write("(");
		    forall_idListCode(end1.end_class, out);
		    antecCode(end1.end_class, end2, out, aliases);
		    conseqCode(end1.end_class, end1, end2, out, aliases);
		    out.write(")");
		}
	    }
            if (end1.navigable) {
		if (end2.end_class.isTemplate()) {
		    for (int i = 0 ; i < classes.size() ; i++) {
			Clase cl = (Clase) classes.get(i);
			Instantiation ins = getInsWhereIsInstantiated(cl);
			if (ins != null) {
			    if (ins.template.equals(end2.end_class)) {
				if (at_least_one) 
				    out.write("\n /\\");
				else 
				    out.write("        consistent(s) is \n");
				at_least_one = true; 
				out.write("(");		
				forall_idListCode(ins.instantiated, out);
				antecCode(ins.instantiated, end1, out, aliases);
				conseqCode(ins.instantiated, end2, end1, out, aliases);
				out.write(")");
			    }
			}
		    }
		}
		else {
		    if (at_least_one) 
			out.write("\n /\\");
		    else 
			out.write("        consistent(s) is \n");
		    at_least_one = true; 
		    out.write("(");
		    forall_idListCode(end2.end_class, out);
		    antecCode(end2.end_class, end1, out, aliases);
		    conseqCode(end2.end_class, end2, end1, out, aliases);
		    out.write(")");
		}
	    }            
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
        return at_least_one;
        
    }
    
    
    private void forall_idListCode(Clase end1, FileWriter out) {
        
        try {
            out.write("all id1: " + end1.name + "_Id :- ");
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void antecCode(Clase end1, End end2, FileWriter out, Vector<RecAlias> aliases) {
        
        try {
            out.write("id1 isin "  + getAlias(end1.name + "s", RECORDFIELD, aliases)
                      + "(s) =>\n");
            if (end2.multiplicity.getMult_type() == 0){  // multiplicity 0..1
		out.write("case ");
		out.write(getAlias(end1.name + "_", MODULENAME, aliases) + "." +  end2.alias + 
                      "(" + getAlias(end1.name + "s", RECORDFIELD, aliases) + "(s)(id1)) of\n");
		out.write("no_" + end2.end_class.name);
		out.write("-> true,\n");
                if (startWithVowel(end2.end_class.name))
                    out.write("an_");
                else
                    out.write("a_");
                out.write(end2.end_class.name+"(id2) -> ");
            }
            else {
                if (end2.multiplicity.getMult_type() == 1) { // multiplicity 1..1
		    out.write("let id2 = ");
		    out.write(getAlias(end1.name + "_", MODULENAME, aliases) + "." +  end2.alias +
			      "(" + getAlias(end1.name + "s", RECORDFIELD, aliases) + "(s)(id1)) in\n");
		}
                else { // multiplicity > 1
		    out.write("(all id2: " + end2.end_class.name + "_Id :- ");
		    out.write("id2 isin ");
		    out.write(getAlias(end1.name + "_", MODULENAME, aliases) + "." +  end2.alias +
			      "(" + getAlias(end1.name + "s", RECORDFIELD, aliases) + "(s)(id1)) =>\n");
		}
            }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }


    private void conseqCode(Clase end1Class, End end1, End end2, FileWriter out, Vector<RecAlias> aliases) {

        try {
            out.write("id2 isin ");
            out.write(getAlias(end2.end_class.name +"s", RECORDFIELD, aliases)+ "(s)");
            if (end1.navigable) {
                out.write(" /\\ ");
                if (end1.multiplicity.getMult_type() == 0){  // multiplicity 0..1
                    if (startWithVowel(end1Class.name))
                        out.write("an_");
                    else
                        out.write("a_");
                    out.write(end1Class.name + "(id1) = ");
                }
                else {
                    if (end1.multiplicity.getMult_type() == 1)  // multiplicity 1..1
                        out.write("id1 = ");
                    else  // multiplicity > 1
                        out.write("id1 isin ");
                }
                out.write(getAlias(end2.end_class.name + "_", MODULENAME, aliases) + "." + end1.alias + 
                          "(" + getAlias(end2.end_class.name +"s", RECORDFIELD,aliases) + "(s)(id2)" +")");
            }
	    if (end2.multiplicity.getMult_type() == 0) // close case
		out.write("\nend");
	    else {
		if (end2.multiplicity.getMult_type() == 1) // close let
		    out.write(" end");
		else // close paren
		    out.write(")");
	    }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
    }

   
    private void  topLevelAbsClassInvariantsCode(Vector<Clase> topLevelCls, FileWriter out, Vector<RecAlias> aliases, 
						boolean at_least_one){

	try{
            for (int i = 0 ; i < topLevelCls.size() ; i++) {
                Clase cl = (Clase) topLevelCls.get(i);
		if (cl.is_abstract) {
		    if (at_least_one)
			out.write(" /\\\n");
		    else
			out.write("        consistent(s) is \n");
		    out.write(" dom " +   getAlias(cl.name + "s", RECORDFIELD, aliases) + "(s) = ");
		    at_least_one = false;
		    for (int j = 0 ; j < relations.size() ; j++) {
			Object o = relations.get(j);
			if (o instanceof Generalization) {
			    Generalization gen = (Generalization) o;
			    if (gen.superclass.name.equals(cl.name)) {
				if (at_least_one)
				    out.write(" union ");
				else
				    at_least_one = true;
				out.write(" dom " + 
					  getAlias(gen.subclass.name + "s", RECORDFIELD, aliases) + "(s)");
			    }
			}
		    }
		    if (!at_least_one)
			out.write(" {}\n");
		}
	    }
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }

    }


    private void topLevelPropertyValuesCode(Vector<Clase> topLevelCls, FileWriter out, Vector<RecAlias> aliases) {
        
        boolean at_least_oneFrozenAtt, at_least_oneAddOnlyAtt, at_least_oneFrozenAsso, 
	    at_least_oneAddOnlyAsso;
        
	for (int i = 0 ; i < topLevelCls.size() ; i++) {
	    Clase cl = (Clase) topLevelCls.get(i);
	    at_least_oneFrozenAtt = thereArePropertyAttsInPostCode(cl, FROZEN);
	    if (at_least_oneFrozenAtt) 
		propertyValuesCode(cl, FROZEN, "Att", out, aliases);
	    at_least_oneAddOnlyAtt = thereArePropertyAttsInPostCode(cl, ADDONLY);
	    if (at_least_oneAddOnlyAtt)
                propertyValuesCode(cl, ADDONLY, "Att", out, aliases);
	    at_least_oneFrozenAsso = thereArePropertyEndsInPostCode(cl, FROZEN);
	    if (at_least_oneFrozenAsso)
		propertyValuesCode(cl, FROZEN, "Assoc",  out, aliases);
	    at_least_oneAddOnlyAsso = thereArePropertyEndsInPostCode(cl, ADDONLY);
	    if (at_least_oneAddOnlyAsso)
		propertyValuesCode(cl, ADDONLY, "Assoc", out, aliases);
	}
    }


    private boolean thereArePropertyAttsInPostCode(Clase topLevelCl, int changeability){

        // It checks if there are attributes with the property FROZEN or ADDONLY given by changeability
        // in the top level class topLevelCl.

        Clase cl;
        boolean at_least_one = false;
        Instantiation ins = getInsWhereIsInstantiated(topLevelCl);

        if (ins != null) 
            cl = ins.template;
        else
            cl = topLevelCl;
        
        // Searchs in the attributes of the class
        for (int i = 0; i < cl.attributes.size() & !at_least_one; i++) {
            Attribute at = (Attribute) cl.attributes.get(i); 
            if (at.changeability == changeability)                  
                at_least_one = true;
        }  

        return at_least_one;
                
    }


    private boolean thereArePropertyEndsInPostCode(Clase topLevelCl, int changeability){

        // It checks if there are navigables associations or parts -depending on "kindOfEnd"- with the
        // property FROZEN or ADDONLY given by "changeability" in the top level class "topLevelCl".

        Clase cl;
        boolean at_least_one = false;
        Instantiation ins = getInsWhereIsInstantiated(topLevelCl);

        if (ins != null) 
            cl = ins.template;
        else
            cl = topLevelCl;

        Vector<End> v = getNavigables(cl);

        // searchs in the ends of the class
        for (int i = 0; i < v.size() & !at_least_one; i++) {
            End end = (End) v.get(i); 
            if (end.changeability == changeability) 
                at_least_one = true;
        }
                      
        return at_least_one;
                
    }


    private void propertyValuesCode(Clase topLevelCl, int changeability, String atOrass, 
                                    FileWriter out, Vector<RecAlias> aliases) {
        
        try{
            out.write("\n      value\n");
            if (changeability == FROZEN)
                out.write("frozen" + atOrass);
            else
                out.write("addOnly" + atOrass);
            out.write("s_in_" + topLevelCl.name + ": Sys >< Sys -> Bool\n");
            if (changeability == FROZEN)
                out.write("frozen" + atOrass);
            else
                out.write("addOnly" + atOrass);
            out.write("s_in_" + topLevelCl.name + "(s',s) is\n");
            if (atOrass.equals("Att"))             
                propertyAttsValuesCode(topLevelCl, changeability, out, aliases);
            else 
                propertyAssosValuesCode(topLevelCl, changeability, out, aliases);
        }
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
    }
   
  
    private boolean propertyAttsValuesCode(Clase topLevelCl, int changeability, FileWriter out, 
					   Vector<RecAlias> aliases){
        
        Clase cl;
	Instantiation ins = getInsWhereIsInstantiated(topLevelCl);
	boolean at_least_one = false;
	    
	if (ins != null) 
	    cl = ins.template;
	else
	    cl = topLevelCl;
	
	for (int i = 0; i < cl.attributes.size() ; i++) {
	    Attribute at = (Attribute) cl.attributes.get(i); 
	    if (at.changeability == changeability) 
		at_least_one = propertyCode(topLevelCl, at.alias, changeability, at_least_one, out, aliases);
	}

	return at_least_one;
	
    }
   
 
    private boolean propertyAssosValuesCode(Clase topLevelCl, int changeability, FileWriter out, 
					    Vector<RecAlias> aliases){
        
        Clase cl;
	Instantiation ins = getInsWhereIsInstantiated(topLevelCl);
	boolean at_least_one = false;
	
	if (ins != null) 
	    cl = ins.template;
	else
	    cl = topLevelCl;
		
	Vector<End> navigables = getNavigables(cl);
	for (int i = 0; i < navigables.size() ; i++) {
	    End end = (End) navigables.get(i); 
	    if (end.changeability == changeability) 
		at_least_one = propertyCode(topLevelCl, end.alias, changeability, at_least_one, out,aliases);
	}
        
	return at_least_one;
        
    }
    

    private boolean propertyCode(Clase topLevelCl, String value, int changeability, 
				 boolean at_least_one, FileWriter out, Vector<RecAlias> aliases){

       String path = new String(getAlias(topLevelCl.name + "_", MODULENAME, aliases) + ".");
       String container = new String(getAlias(topLevelCl.name + "s", RECORDFIELD, aliases));

        try{
	    if (at_least_one)
		out.write("/\\\n");
	    else
		at_least_one = true;
	    out.write("         (all id: " + topLevelCl.name + "_Id :-");
	    out.write("(id isin " + container + "(s) /\\ id isin " + container + "(s')) =>");
	    out.write(path + value + "(" +  container + "(s)(id))");
	    if (changeability == ADDONLY) 
		out.write(" <<= ");
	    else
		out.write(" = ");
	    out.write(path + value + "(" +  container + "(s')(id)))");
	}               
        catch (IOException e) {
            System.out.println("Error in output file");
        }
        
        return at_least_one;
            
    }


    private void resolveNames(Vector<RecAlias> aliases) {

        resolveModuleAliases(aliases);
        resolveTopLevelRecordAliases(aliases);
        assignRoleNames();
        resolveValuesAliases();
    }
    

    private void resolveModuleAliases(Vector<RecAlias> aliases) {

        // It creates alias for module names.

        for (int i = 0; i < classes.size(); i++) {
            Clase cl = (Clase) classes.get(i);
            createAlias(cl.name, cl.name.toUpperCase(), MODULENAME, aliases);  // root name for the module name
            String alias = getAlias(cl.name, MODULENAME, aliases);
            createAlias(cl.name + "_", alias + "_", MODULENAME, aliases);
            createAlias(cl.name + "S_", alias + "S_", MODULENAME, aliases);
	    createAlias(cl.name + "__", alias + "__", MODULENAME, aliases);
	}
    }


    private void assignRoleNames(){

        // It assign the name of the association to the association ends as rolenames and aliases.
        // Afterwards, if it is necessary, resolveValuesAliases() will assign a different alias.

        for (int i = 0; i < relations.size(); i++) {
            Object o = relations.get(i);
            if (o instanceof Association) {
                Association asso = (Association) o;
                for (int j = 0; j < asso.ends.size() ; j++) {
                    End end = (End)asso.ends.get(j);
                    end.role_name = asso.name;
                    end.alias = asso.name;
                }
            }
        }
    }


    private void resolveTopLevelRecordAliases(Vector<RecAlias> aliases) {

        // It creates alias for the observers of the top level record.

	for (int i = 0; i < classes.size(); i++) {
            Clase cl = (Clase) classes.get(i);
	    createAlias(cl.name + "s", cl.name.toLowerCase() + "s", RECORDFIELD, aliases);
        }
    }
    

    private void resolveValuesAliases(){
        
        // It creates alias for operations and associations.
        // The attributes and (attributes translated as compositions) hold their original name as alias.
        

        int num;

        for (int i = 0; i < classes.size(); i++) {
            Clase cl = (Clase) classes.get(i);
            for (int j = 0; j < cl.operations.size(); j++) {
                Operation op = (Operation) cl.operations.get(j);
                num = getNumberOfPreviousEqualValuesNames(cl.attributes, cl.operations, null, j, op.name);
                if (num != 0)
                    op.alias = new String(op.name + Integer.toString(num));
            }
            
        }

        for (int i = 0; i < relations.size(); i++){
            Object o = relations.get(i);
            if (o instanceof Association) {
                Association asso = (Association) o;
                for (int j = 0; j < asso.ends.size() ; j++) {
                    End end = (End)asso.ends.get(j);
                    if (end.navigable) {
                        for (int k = 0 ; k < asso.ends.size() ; k++) {
                            if (k != j) {
                                End end1 = (End) asso.ends.get(k);
                                Vector<End> nav_ends = getNavigables(end1.end_class); // Associations 
                                                                                 // (it includes comps.)
                                num = getNumberOfPreviousEqualValuesNames(end1.end_class.attributes, 
                                                                          end1.end_class.operations,
                                                                          nav_ends, nav_ends.indexOf(end1),
                                                                          end.role_name);
                                if (num != 0)
                                    end.alias = new String(end.role_name + Integer.toString(num));
                            }
                        }
                    }
                }
            }
        }
    }

  
    private void createAlias(String name, String possiblealias, int kind, Vector<RecAlias> aliases) {

       //  Create alias for name.
        
       String alias;
              
       if (aliasNeedsPostfix(possiblealias, aliases, kind)) 
           alias = new String(possiblealias + Integer.toString(createPostfix(possiblealias, aliases, kind)));
       else 
           alias = new String(possiblealias);
       aliases.addElement(new RecAlias(name, alias, kind));
       //System.out.println(name + " " + alias);
                  
   }
  

   private boolean aliasNeedsPostfix(String alias, Vector<RecAlias> aliases, int kind) {

       RSLKeywordTable rslKeywordT = new RSLKeywordTable();
       boolean needs = rslKeywordT.contains(alias) | existsAlias(alias, aliases, kind);

       //if (needs) 
       //   System.out.println( alias + " needs post");
       // else
       //   System.out.println( alias + " do not need post");

       return needs;

    }


    private int createPostfix(String alias, Vector<RecAlias> aliases, int kind) {

        int j;

        for (j = 1 ; aliasNeedsPostfix(alias + Integer.toString(j), aliases, kind) ; j++);
        return j;
                        
    }


    private boolean existsAlias(String alias, Vector<RecAlias> aliases, int kind) {

        RecAlias recAlias;
        boolean found = false;
        
	for (int i = 0 ; i < aliases.size() & !found ; i++) {
            recAlias = (RecAlias) aliases.get(i);
//	    System.out.println( alias + " " + i + "-" + recAlias.getAlias());
            if (recAlias.getAlias().equals(alias) & kind == recAlias.getKind())
		found = true;
	}

        return found;

    }


    private String getAlias(String name, int kind, Vector<RecAlias> aliases) {

        //Returns the alias associated to name for a given kind (MODULENAME or RECORDFIELD)

        boolean found = false;
        String alias = null;
        
        for (int i = 0 ; i < aliases.size() & ! found ; i++) {
            RecAlias ra = (RecAlias) aliases.get(i);
	    if (ra.getName().equals(name) & kind == ra.getKind()) {
                alias = ra.getAlias();
                found = true;
            }
        }

        return alias;

    }


    private Instantiation getInsWhereIsInstantiated(Clase cl) {

        boolean is = false;
        Object o;
        Instantiation ins = null;
                
        for (int i = 0 ; i < relations.size() & !is ; i++) {
            o = relations.get(i);
            if (o instanceof Instantiation) {
                ins = (Instantiation) o;
                if (cl.name.equals(ins.instantiated.name))
                    is = true;
            }
        }
        if (!is)
            ins = null;
        
        return ins;
    }


    private Generalization getGenWhereIsSubclass(Clase cl) {

        boolean is = false;
        Object o;
        Generalization gen = null;
        
        
        for (int i = 0 ; i < relations.size() & !is ; i++) {
            o = relations.get(i);
            if (o instanceof Generalization) {
                gen = (Generalization) o;
                if (cl.name.equals(gen.subclass.name))
                    is = true;
            }
        }
        if (!is)
            gen = null;
        
        return gen;
    }


    private Vector<End> getNavigables(Clase cl) {

        // Returns all the navigables ends of cl, including compositions.

        Vector<End> navigables = new Vector<End>(10, 1);
        Object o;
        Association asso;
        End end;
        
        for (int i = 0 ; i < relations.size() ; i++) {
            o = relations.get(i);
            if (o instanceof Association) {
                asso = (Association) o;
                for (int j = 0 ; j < asso.ends.size() ; j++) {
                    end = (End) asso.ends.get(j);
                    if (end.end_class.name.equals(cl.name)) {
                        for (int k = 0 ; k < asso.ends.size() ; k++) {
                            if (k != j) {
                                end = (End) asso.ends.get(k);
                                if (end.navigable)
                                    navigables.addElement(end);
                            }
                        }
                    }
                }
            }
        }
        //System.out.println("NAVIGABLES IN " + cl.name + "=" +navigables.size());
        //for (int i = 0 ; i < navigables.size() ; i++) {
        //  end  = (End) navigables.get(i);
        //  System.out.println(end.role_name);
        //}
        return navigables;
    }


    private boolean startWithVowel(String s) {
        
        return (s.charAt(0) == 'A' | s.charAt(0) == 'E' | s.charAt(0) == 'I' | s.charAt(0) == 'O' |
		s.charAt(0) == 'a' | s.charAt(0) == 'e' | s.charAt(0) == 'i' | s.charAt(0) == 'o');
    }


    private int getNumberOfPreviousEqualValuesNames(Vector<Attribute> atts, Vector<Operation> ops, Vector<End> navigables, int pos, String name) {

        int size_a, size_n, size_o;

        if (navigables == null) {
            // Ii is an operation. It search on attributes and previous operations.
            size_a = atts.size();
            size_o = pos;
            size_n = 0;    
        }
        else {
            // It is an association end. It search on attributes, operations and previous ends.
            size_a = atts.size();
            size_o = ops.size();
            size_n = pos;
        }  
                
        int num = 0;

        for (int i = 0; i < size_a; i++) {
            Attribute at = (Attribute) atts.get(i);
            if (at.name.equals(name)) // atribute (even compositions)
                num++;
        }

        for (int i = 0; i < size_o; i++) {
            Operation op = (Operation) ops.get(i);
            if (op.name.equals(name)) 
                num++;
        }

        for (int i = 0; i < size_n; i++) {
            End end = (End) navigables.get(i);
            if (end.role_name.equals(name)){
                num++;
            }
        }
        
        return num;
    }


    private Vector<End> getParts(Clase cl) {

        // Returns the parts of cl (from its associations and its attributes). 

        Vector<End> parts = new Vector<End>(10, 1);
                
        for (int i = 0 ; i < relations.size() ; i++) {
            Object o = relations.get(i);
            if (o instanceof Association) {
                Association asso = (Association) o;
                for (int j = 0 ; j < asso.ends.size() ; j++) {
                    End end = (End) asso.ends.get(j);
                    if (end.end_class.name.equals(cl.name) & end.kind.equals("composite")){
                        for (int k = 0 ; k < asso.ends.size() ; k++) {
                            if (k != j) {
                                 end = (End) asso.ends.get(k);
				 parts.addElement(new End(end.end_class, end.role_name, end.alias, 
				       end.multiplicity, end.navigable, end.kind, end.changeability)); 
                            }
                        }
                    }
                }
            }
        }
        
        for (int i = 0 ; i < cl.attributes.size() ; i++) {
            Attribute att = (Attribute) cl.attributes.get(i);
            Clase end_class = getClase(att.type);
            if (end_class != null) 
                parts.addElement(new End(end_class, att.name, att.alias, att.multiplicity, true,
					 "none", att.changeability));
	}

        //System.out.println("COMPOSITIONS in " + cl.name + " " + parts.size());
        //for (int i = 0; i < parts.size(); i++) {
        //End end = (End) parts.get(i);
        //  System.out.println(end.role_name);
        //}
        
        return parts;
    }


}

/*=======================================================================================================*/

class Pair {

    String c1, c2;

    public Pair(String p1, String p2) {
        
        c1 = p1;
        c2 = p2;
    }

}

/*=======================================================================================================*/


class RecAlias {

    String name, alias;
    int kind;

    public RecAlias(String n, String a, int k) {
        
        name = n;
        alias = a;
        kind = k;
    }


    public String getAlias(){
        
        return alias;

    }

    public String getName() {
        
        return name;
    
    }

    public int getKind() {
        
        return kind;
    
    }
}

/*=======================================================================================================*/

class  EquivalentTypes{
    
    String umlType, rslType;
    
    public EquivalentTypes(String umlT, String rslT) {
	
	umlType = umlT;
	rslType = rslT;
    }
}

/*=======================================================================================================*/

class  EquivalentTypesTable{
    
    Vector<EquivalentTypes> ett;  // Equivalence table of data types beetween standard Magic Draw types and RSL types.

    public EquivalentTypesTable() {
	
	ett = new Vector<EquivalentTypes>(3, 1);
	ett.addElement(new EquivalentTypes(new String("boolean"), new String("Bool")));
	ett.addElement(new EquivalentTypes(new String("char"), new String("Char")));
	ett.addElement(new EquivalentTypes(new String("double"), new String("Real")));
	// int is not considered equivalent to Int because it is an RSL keyword and consequently is not accepted
	// by method wellFormed .
	// for MagicDraw 9.5
	ett.addElement(new EquivalentTypes(new String("Integer"), new String("Int")));
    }

    public String getEquivalentType(String t) {

	boolean found = false;
	EquivalentTypes et = null;

	for (int i = 0 ; i < ett.size() & !found ; i++){
	    et = ((EquivalentTypes) ett.get(i));
	    if (et.umlType.equals(t))
		found = true;
	}

	if (found)
	    return et.rslType;
	else
	    return null;
	
    }
		
	    
}

/*=======================================================================================================*/

class  RSLKeywordTable{
    
    Vector<String> kwt;  // RSL Keyword table.

    public RSLKeywordTable() {
	
	 kwt = new Vector<String>(60, 1);

	kwt.addElement(new String("Bool"));
	kwt.addElement(new String("Char"));
	kwt.addElement(new String("Int"));
	kwt.addElement(new String("Nat"));
	kwt.addElement(new String("Real"));
	kwt.addElement(new String("Text"));
	kwt.addElement(new String("Unit"));
	kwt.addElement(new String("abs"));
	kwt.addElement(new String("any"));
	kwt.addElement(new String("as"));
	kwt.addElement(new String("axiom"));
	kwt.addElement(new String("card"));
	kwt.addElement(new String("case"));
	kwt.addElement(new String("channel"));
	kwt.addElement(new String("chaos"));
	kwt.addElement(new String("class"));
	kwt.addElement(new String("do"));
	kwt.addElement(new String("dom"));
	kwt.addElement(new String("elems"));
	kwt.addElement(new String("else"));
	kwt.addElement(new String("elsif"));
	kwt.addElement(new String("end"));
	kwt.addElement(new String("extend"));
	kwt.addElement(new String("false"));
	kwt.addElement(new String("for"));
	kwt.addElement(new String("forall"));
	kwt.addElement(new String("hd"));
	kwt.addElement(new String("hide"));
	kwt.addElement(new String("if"));
	kwt.addElement(new String("in"));
	kwt.addElement(new String("inds"));
	kwt.addElement(new String("initialise"));
	kwt.addElement(new String("int"));
	kwt.addElement(new String("len"));
	kwt.addElement(new String("let"));
	kwt.addElement(new String("local"));
	kwt.addElement(new String("object"));
	kwt.addElement(new String("of"));
	kwt.addElement(new String("out"));
	kwt.addElement(new String("post"));
	kwt.addElement(new String("pre"));
	kwt.addElement(new String("read"));
	kwt.addElement(new String("real"));
	kwt.addElement(new String("rng"));
	kwt.addElement(new String("scheme"));
	kwt.addElement(new String("skip"));
	kwt.addElement(new String("stop"));
	kwt.addElement(new String("swap"));
	kwt.addElement(new String("then"));
	kwt.addElement(new String("tl"));
	kwt.addElement(new String("true"));
	kwt.addElement(new String("type"));
	kwt.addElement(new String("until"));
	kwt.addElement(new String("use"));
	kwt.addElement(new String("value"));
	kwt.addElement(new String("variable"));
	kwt.addElement(new String("while"));
	kwt.addElement(new String("with"));
	kwt.addElement(new String("write"));
    }

   public boolean contains(String s) {

	boolean isin = false;

	for (int i = 0; i < kwt.size() & !isin; i++) {
	    String kw = (String) kwt.get(i);
	    if (kw.equals(s))
		isin = true;
	}
	return isin;
	}
}
		
/*=======================================================================================================*/



